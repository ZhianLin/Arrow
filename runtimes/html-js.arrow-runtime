<!DOCTYPE html>
<html>
    <!--
        Arrow
        HTML-JS Runtime
        Mor. H. Golkar
    -->
    <head>
        <title>{{project_title}}</title>
        <meta charset="utf-8">
        <meta name="color-scheme" content="dark light">
        <meta name="keywords" content="Arrow,adventure,{{project_title}}">
        <meta name="description" content="{{project_title}}: An adventure made with Arrow">
        <!-- @inline -->
        <script>
/*project.js*/

// Arrow HTML-JS Runtime: Project (JSON) data

const PROJECT = {/*project_json*/};

</script>
        <script>
/*./modules/shared-i18n.js*/

// Arrow HTML-JS Runtime: i18n (internationalization) module

const _SUPPORTED_LOCALES = ["en"];

const _TRANSLATION_TABLE = {
    skip: {
        en: "Skip",
    },
    continue: {
        en: "Continue",
    },
    false: {
        en: "False",
    },
    true: {
        en: "True",
    },
    generate: {
        en: "Generate",
    },
    dialog_anonymous_character_name: {
        en: "Anonymous",
    },
    apply: {
        en: "Apply",
    },
    invalid: {
        en: "Invalid",
    },
    user_input_default_bool_negative: {
        en: "Negative (False)",
    },
    user_input_default_bool_positive: {
        en: "Positive (True)",
    },
    evaluate: {
        en: "Evaluate",
    },
    match: {
        en: "Match",
    },
    eol: {
        en: "EOL",
    },
    eol_node: {
        en: "EOL: {node_name}",
    },
};

function i18n(string_id, lang){
    // default to `_LOCALE` if the target `lang` is not annotated or supported 
    if ( _SUPPORTED_LOCALES.includes(lang) == false ) lang = _LOCALE;
    if ( _TRANSLATION_TABLE.hasOwnProperty(string_id) ) {
        if ( _TRANSLATION_TABLE[string_id].hasOwnProperty(lang) ) {
            return _TRANSLATION_TABLE[string_id][lang];
        } else {
            throw new Error(`Incomplete Translation Table: value for the selected locale doesn't exist! _TRANSLATION_TABLE[${string_id}][${lang}]`);
        }
    } else {
        throw new Error(`I18n translation table doesn't include the string id: ${string_id} `);
    }
}

</script>
        <script>
/*./modules/shared-bbcode-parser.js*/

// Arrow HTML-JS Runtime: BBCode parser module

// This parser is a modified fork of
// [JS BBCode Parser v3.0.4 - License: MIT](https://github.com/DasRed/js-bbcode-parser)

const DEFAULT_BBCODE_MAPPING = {

    '\\[br\\]': '<br>',

    '\\[b\\](.+?)\\[/b\\]': '<strong>$1</strong>',
    '\\[i\\](.+?)\\[/i\\]': '<em>$1</em>',
    '\\[u\\](.+?)\\[/u\\]': '<u>$1</u>',

    '\\[h1\\](.+?)\\[/h1\\]': '<h1>$1</h1>',
    '\\[h2\\](.+?)\\[/h2\\]': '<h2>$1</h2>',
    '\\[h3\\](.+?)\\[/h3\\]': '<h3>$1</h3>',
    '\\[h4\\](.+?)\\[/h4\\]': '<h4>$1</h4>',
    '\\[h5\\](.+?)\\[/h5\\]': '<h5>$1</h5>',
    '\\[h6\\](.+?)\\[/h6\\]': '<h6>$1</h6>',

    '\\[p\\](.+?)\\[/p\\]': '<p>$1</p>',

    '\\[color=(.+?)\\](.+?)\\[/color\\]':  '<span style="color:$1">$2</span>',
    '\\[size=([0-9]+)\\](.+?)\\[/size\\]': '<span style="font-size:$1px">$2</span>',

    '\\[img\\](.+?)\\[/img\\]': '<img src="$1">',
    '\\[img=(.+?)\\]':          '<img src="$1">',

    '\\[email\\](.+?)\\[/email\\]':       '<a href="mailto:$1">$1</a>',
    '\\[email=(.+?)\\](.+?)\\[/email\\]': '<a href="mailto:$1">$2</a>',

    '\\[url\\](.+?)\\[/url\\]':                      '<a href="$1">$1</a>',
    '\\[url=(.+?)\\|onclick\\](.+?)\\[/url\\]':      '<a onclick="$1">$2</a>',
    '\\[url=(.+?)\\starget=(.+?)\\](.+?)\\[/url\\]': '<a href="$1" target="$2">$3</a>',
    '\\[url=(.+?)\\](.+?)\\[/url\\]':                '<a href="$1">$2</a>',

    '\\[a=(.+?)\\](.+?)\\[/a\\]': '<a href="$1" name="$1">$2</a>',

    '\\[list\\](.+?)\\[/list\\]': '<ul>$1</ul>',
    '\\[\\*\\](.+?)\\[/\\*\\]':   '<li>$1</li>',

    '\\[attr=(.+?)\\svalue=(.+?)\\](.+?)\\[/attr\\]': '<span $1="$2">$3</span>',
    '\\[attr=(.+?)\\](.+?)\\[/attr\\]':               '<span $1>$2</span>',
    
    '\\[style=(.+?)\\](.+?)\\[/style\\]': '<span style="$1">$2</span>',

};

class BBCodeParser {

    constructor(codes) {
        this.codes = [];
        this.setCodes(codes);
    }

    parse(text) {
        return this.codes.reduce((text, code) => text.replace(code.regexp, code.replacement), text);
    }

    add(regex, replacement) {
        this.codes.push({
            regexp: new RegExp(regex, 'igm'),
            replacement: replacement
        });
        return this;
    }

    setCodes(codes) {
        this.codes = Object.keys(codes).map(function (regex) {
            const replacement = codes[regex];
            return {
                regexp: new RegExp(regex, 'igm'),
                replacement: replacement
            };
        }, this);
        return this;
    }

}

const DEFAULT_BBCODE_PARSER = new BBCodeParser(DEFAULT_BBCODE_MAPPING); 

</script>
        <script>
/*./modules/shared.js*/

// Arrow HTML-JS Runtime: Shared utility (static) functions

function safeInt(maybe_number, replacement, allow_none_integer_replacement) {
    if ( Number.isInteger(replacement) == false && allow_none_integer_replacement !== true ) replacement = (-1);
    var result = parseInt(maybe_number);
        result = ( Number.isInteger(result) ? result : replacement );
    return result;
}

function safeBool(maybe_bool){
    var result = null;
    if ( typeof maybe_bool != 'boolean' ){
        if ( typeof maybe_bool == 'string' ){
            maybe_bool = maybe_bool.toLowerCase();
            if ( maybe_bool === "true" ){
                result = true;
            } else if ( maybe_bool === "false" ){
                result = false;
            }
        }
    } else {
        result = maybe_bool;
    }
    if ( result === null ){
        result = ( !!(maybe_bool) );
    }
    return result;
}

function object_has_keys_all(object, expected_keys_array) {
    for (const object_key of expected_keys_array) {
        if ( object.hasOwnProperty(object_key) == false ){
            return false;
        }
    }
    return true;
}

function remap_connections_for_slots(map, owner_node_id){
    if ( typeof map == 'object' && typeof owner_node_id == 'number' && owner_node_id >=0 ){
        var remap_for_slots = [];
        if ( map.hasOwnProperty("io") && Array.isArray(map.io) ){
            for (const connection of map.io) {
                // <connection>[ from_id, from_slot, to_id, to_slot ]
               if ( connection.length >= 4 && connection[0] == owner_node_id ){
                    remap_for_slots[ connection[1] ] = { "id": connection[2], "slot": connection[3] };
               }
            }
        }
        return remap_for_slots;
    } else {
        throw new Error("Unable to remap connections for slots: Called with wrong arguments.");
    }
}

function create_node_base_html(node_id, node_resource, tag){
    var html = document.createElement(tag || 'div');
        html.className = 'node';
        html.setAttribute('data-type',  node_resource.type);
        html.setAttribute('data-name',  node_resource.name);
        html.setAttribute('data-uid',   node_id.toString());
    return html;
}

function create_element(tag, inner, attributes){
    var element = document.createElement(tag);
    if ( inner ){
        if ( typeof inner == 'string' ){
            element.innerHTML = inner;
        } else if ( inner instanceof Element ){
            element.appendChild(inner);
        }
    }
    if (typeof attributes == 'object') {
        for (const attr in attributes) {
            if (attributes.hasOwnProperty(attr)) {
                element.setAttribute(attr, attributes[attr]);
            }
        }
    }
    return element;
}

function ellipsis(text, length) {
    return text.substr(0, length) + (text.length > length ? "..." : "")
}

function format(text, pairs, case_insensitive){
    // replacing every `{tag}` in `text` with value of `pairs[tag]`
    if ( typeof text == 'string' && typeof pairs == 'object' ){
        for (const key in pairs) {
            if (pairs.hasOwnProperty(key)) {
                const tag = '{' + key + '}';
                const pattern = new RegExp(tag, (case_insensitive === true ? 'gi' : 'g')); // i.e. `g`lobally search for every key
                const replacement = pairs[key];
                text = text.replace( pattern , replacement );
            }
        }
        return text;
    } else {
        throw new Error("Unable to format text: Called with wrong arguments.");
    }
}

function parse_bbcode(text, return_text_anyway){
    // returns `text/html`
    if (typeof text == 'string'){
        return DEFAULT_BBCODE_PARSER.parse(text);
    } else {
        // ... or if the input is not what expected
        if (return_text_anyway === false){ // error
            throw new Error("Unable to parse BBCode: Called with wrong arguments.");
        } else { // or by default an empty string ''
            return "";
        }
    }
}

function string_begins_with(string, rhs){
    if ( typeof string == 'string' && typeof rhs == 'string'){
        return ( string.indexOf(rhs) == 0 );
    } else {
        throw new Error("Called with Wrong Arguments: Expected two strings.");
    }
}

function string_ends_with(string, rhs){
    if ( typeof string == 'string' && typeof rhs == 'string'){
        var last_index_of_rhs = string.lastIndexOf(rhs);
        return ( last_index_of_rhs >= 0 && last_index_of_rhs === ( string.length - rhs.length ) );
    } else {
        throw new Error("Called with Wrong Arguments: Expected two strings.");
    }
}

// Replicates `Godot[v3.2.x]::String::capitalize`:
// For `capitalize camelCase mixed_with_underscores`, it will return `Capitalize Camel Case Mixed With Underscores`.
function capitalize(string){
    if ( typeof string == 'string' ){
        // Replaces underscores with spaces
        var replaced = string.replace(/_/gi, " ");
        // adds spaces before in-word uppercase characters
        var result = "";
        for ( var cidx = 0; cidx < replaced.length; cidx++ ){
            var chr = replaced.charAt(cidx);
            var chr_upper = chr.toUpperCase();
            result += ( chr != " " && chr == chr_upper ? ` ${chr}` : chr );
        }
        // converts all letters to lowercase
        // then capitalizes the first letter and every letter following a space character.
        result = result.split(" ");
        for( var widx = 0; widx < result.length; widx++ ){
            var low_word = result[widx].toLowerCase();
            result[widx] = ( low_word.charAt(0).toUpperCase() + low_word.substring(1) );
        }
        result = result.join(" ");
        return result;
    } else {
        throw new Error("Called with Wrong Arguments: Expected string.");
    }
}

const inclusiveRandInt = function(_min, _max, base, negative, even, odd) {
    if( arguments.length < 2 ){
        _max = _min;
		_min = 0;
	}
    _min = ( Number.isFinite( _min ) ? Math.ceil(_min) : 0 );
    _max = ( Number.isFinite( _max ) ? Math.floor(_max) : 0 );
    var max = Math.max(_min, _max);
    var min = Math.min(_min, _max);
	let result = null;
    do {
        result = Math.floor(Math.random() * (max - min + 1)) + min;
        if ( even != odd ){
            let is_even = ((result % 2) == 0);
            if ( is_even && even == false ) result = null;
            if ( is_even == false && odd == false ) result = null;
        }
    } while (result == null);
    if ( negative === true ) result = (result * (-1));
	if ( Number.isInteger(base) && base >= 2 && base <= 36  ){
        return result.toString(base);
    } else {
        return result;
    }
};

</script>
        <script>
/*./modules/condition.js*/

// Arrow HTML-JS Runtime: Condition node module

class Condition {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        const FALSE_SLOT = 0;
        const TRUE_SLOT  = 1;
        
        const UNSET_CONDITION_MESSAGE = "Condition unset or invalid!";

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = parseInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 || slot_idx > 1 ){
                // We default to `false` anytime something is wrong but we can continue
                slot_idx = FALSE_SLOT; 
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {            
            // Skipped? The convention is to ...
            this.html.setAttribute('data-skipped', true);
            // ... react by playing the *False Slot First*
            if ( this.slots_map.hasOwnProperty(FALSE_SLOT) ){ // if false slot is connected
                this.play_forward_from(FALSE_SLOT);
            }
            else { // otherwise playing the *Only Remained [Possibly Connected] True Slot*
                this.play_forward_from(TRUE_SLOT); // which ...
            } // ... will naturally end the plot line if the true slot is not connected
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };

        this.evaluation_and_play = function(){
            var evaluation = null;
            if ( this.condition_statement ) {
                evaluation = this.condition_statement.evaluate();
                // ... It may result in `null` (e.g. if the statement is unset.)
            }
            if ( typeof evaluation != 'boolean' ) {
                evaluation = false; // reset to default `false` if there is no valid evaluation ...
                if (_VERBOSE) console.warn(`Evaluation of Condition (${this.node_resource.name}) Failed, therefore considered as 'False'.`);
            }
            this.play_forward_from(
                ( evaluation == true) ? TRUE_SLOT : FALSE_SLOT
            );
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else {
                    this.evaluation_and_play();
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Statement
                this.condition_statement = null;
                if ( this.node_resource.hasOwnProperty("data") ){
                    try {
                        this.condition_statement = new ConditionStatement(this.node_resource.data, VARS);
                    } catch(err){
                        if (_VERBOSE) console.warn('Unable to Parse Condition. Error:' + err);
                    }
                }
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    // Parsed Condition Statement:
                    if ( this.condition_statement ){
                        var parsed_condition_statement = (this.condition_statement.parse() || UNSET_CONDITION_MESSAGE);
                        this.parsed_statement = create_element("code", parsed_condition_statement, {"class": "statement"});
                        this.html.appendChild(this.parsed_statement);
                    }
                    // False:
                    this.false_button = create_element("button", i18n("false"), { "value": "false" });
                    this.false_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, FALSE_SLOT) );
                    this.html.appendChild(this.false_button);
                    // True:
                    this.true_button = create_element("button", i18n("true"), { "value": "true" });
                    this.true_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, TRUE_SLOT) );
                    this.html.appendChild(this.true_button);
            }
            return this;
        }
        throw new Error("Unable to construct `Condition`");
    }

}

class ConditionStatement {

    /*  Note:
        (convention)
        length comparisons can get a str(int) as `with` value or a str(string)
        in the first case the stringified integer will be parsed as the length of the right-hand-side,
        and in the latter case, the `.length()` of the string will be used in the comparison.
    */

    constructor(data, variables){

        const _self = this;

        this.data = null;
        this.variable = null;

        const PARAMETER_MODES_ENUM = {
            0: "value",
            1: "variable"
        };
        const PARAMETER_MODES_ENUM_CODE = {
            "value": 0,
            "variable": 1
        };
        
        const COMPARISON_OPERATORS = {
            "num": {
                "eq": { "text": "is Equal", "sign": "==" },
                "nq": { "text": "is Not Equal", "sign": "!=" },
                "gt": { "text": "is Greater", "sign": ">" },
                "gte": { "text": "is Greater or Equal", "sign": ">=" },
                "ls": { "text": "is Lesser", "sign": "<" },
                "lse": { "text": "is Lesser or Equa)", "sign": "<=" },
            },
            "str": {
                "rgx":{ "text": "Matches RegEx Pattern", "sign": "~=" },
                "ct":{ "text": "Contains Substring", "sign": "%~" },
                "cts":{ "text": "Contains Substring (Case-Sensitive)", "sign": "%=" },
                "bgn":{ "text": "Begins with", "sign": "^=" },
                "end":{ "text": "Ends with", "sign": "=^" },
                "eql":{ "text": "Has Equal Length", "sign": "#=" },
                "lng":{ "text": "Is Longer", "sign": "#>" },
                "shr":{ "text": "Is Shorter", "sign": "#<" },
            },
            "bool": {
                "eq": { "text": "Conforms", "sign": "=="},
                "nq": { "text": "Doesn't Conform", "sign": "!="},
            },
        };

        const KEYS_NEEDED_TO_PARSE = ["variable", "operator", "with"];
        
        const STATEMENT_TEMPLATE = "{ident} {operator_sign} {parameter}";
        const COMPARED_TO_SELF_INITIAL_RIGHT_SIDE = "Self (Intial Value)";
        
        const STRING_VALUE_FORMATING_TEMPLATE = "`%s`";
    
        this.parse = function(){
            var parsed = null;
            if ( this.variable && this.data ) {
                this.statement = { "ident": null, "operator_sign": null, "parameter": null };
                this.statement.ident = this.variable.name;
                if ( COMPARISON_OPERATORS[this.variable.type].hasOwnProperty(this.data.operator) ){
                    this.statement.operator_sign = COMPARISON_OPERATORS[this.variable.type][this.data.operator].sign;
                }
                switch ( this.data.with[0] ){
                    case PARAMETER_MODES_ENUM_CODE.value:
                        if (this.variable.type == "str"){
                            this.statement.parameter = STRING_VALUE_FORMATING_TEMPLATE.replace("%s", this.data.with[1]);
                        } else {
                            this.statement.parameter = this.data.with[1];
                        }
                        break;
                    case PARAMETER_MODES_ENUM_CODE.variable:
                        if ( this.data.with[1] == this.data.variable) { // the variable is compared to self (initial value)
                            this.statement.parameter = COMPARED_TO_SELF_INITIAL_RIGHT_SIDE;
                        } else { // or another variable
                            if ( VARS.hasOwnProperty(this.data.with[1]) ) {
                                var parameter_var = VARS[ this.data.with[1] ];
                                this.statement.parameter = parameter_var.name;
                            }
                        }
                        break;
                }
                for (const key in this.statement) {
                    if ( this.statement.hasOwnProperty(key) ) {
                        if ( this.statement[key] === null ){
                            this.statement = null;
                            break;
                        }
                    }
                }
                parsed = (this.statement ? format(STATEMENT_TEMPLATE, this.statement) : null );
            }
            return parsed;
        };

        //  `evaluate_str_comparison` can give a number as input, but it comes from a textual input
        //  also it may compare two real strings (str variables) so we shall
        //  detect what user have had in mind:
        this.smart_length_parse = function(input){
            if ( typeof input == 'number' ){
                return safeInt(input, 0);
            } else if ( typeof input == 'string' ) {
                var parsed_input = parseInt(input);
                if ( parsed_input.toString() == input ){
                    // if input is only a number inputted as string, it will be returned as the length (parsed)
                    return parsed_input;
                } else { //  otherwise ...
                    //... the length of the string is the result
                    return input.length;
                }
            } else {
                return 0;
            }
        };
            
        this.evaluators = {
            "str": function(left, operation, right){ 
                var result = null;
                switch (operation) {
                    case "rgx": // Matches RegEx Pattern
                        try {
                            var regex = new RegExp(right);
                            result = ( left.search(regex) >= 0);
                        } catch(err) {
                            if (_VERBOSE){
                                console.warn(`Evaluation Failed! Bad RegEx Match Operation: ` + err);
                                console.warn(arguments);
                            }
                        }
                        break;                    
                    case "ct": // Contains Substring
                        var l = left.toLowerCase();
                        var r = right.toLowerCase();
                        result = (l.indexOf(r) >= 0);
                        break;
                    case "cts": // Contains Substring (Case-Sensitive)
                        result = (left.indexOf(right) >= 0);
                        break;
                    case "eql": // Has Equal Length
                        result = (left.length == _self.smart_length_parse(right));
                        break;
                    case "lng": // Is Longer
                        result = (left.length > _self.smart_length_parse(right));
                        break;
                    case "shr": // Is Shorter
                        result = (left.length < _self.smart_length_parse(right));
                        break;
                    case "bgn": // Begins with
                        result = string_begins_with(left, right);
                        break;
                    case "end": // Ends with
                        result = string_ends_with(left, right);
                        break;
                }
                return result;
            },
            "num": function(left, operation, right){
                var result = null;
                switch (operation) {
                    case "eq": // is Equal
                        result = ( left == right);
                        break;
                    case "nq": // is Not Equal
                        result = ( left != right);
                        break;
                    case "gt": // is Greater
                        result = ( left > right);
                        break;
                    case "gte": // is Greater or Equal
                        result = ( left >= right);
                        break;
                    case "ls": // is Lesser
                        result = ( left < right);
                        break;
                    case "lse": // is Lesser or Equal
                        result = ( left <= right);
                        break;
                }
                return result;
            },
            "bool": function(left, operation, right){
                var result = null;
                switch (operation){
                    case "eq":
                        result = (left == right);
                        break;
                    case "nq":
                        result = (left != right);
                        break;
                }
                return result;
            }
        };

        this.evaluate = function(){
            var result = null;
            if ( this.variable ){
                var type  = this.variable.type;
                var value = this.variable.value;
                var with_value;
                switch ( this.data.with[0] ) {
                    case PARAMETER_MODES_ENUM_CODE.value:
                        with_value = this.data.with[1];
                        break;
                    case PARAMETER_MODES_ENUM_CODE.variable:
                        var the_second_variable_id = this.data.with[1];
                        if ( VARS.hasOwnProperty(the_second_variable_id) ){
                            if (the_second_variable_id == this.data.variable){
                                // compared to itself (self initial value)
                                with_value = VARS[the_second_variable_id].init;
                            } else {
                                with_value = VARS[the_second_variable_id].value;
                            }
                        }
                        break;
                }
                // now we have whatever we need, just make sure the comparee value is right
                if ( with_value !== null ) {
                    if ( type == "str" && ( typeof with_value != 'string') ){
                        with_value = with_value.toString();
                    } else if ( type == "num" && (typeof with_value != 'number') ){
                        with_value= safeInt(with_value, 0);
                    } else if ( type == "bool" && (typeof with_value != 'boolean') ){
                        with_value= safeBool(with_value);
                    }
                    // lets evaluate for the type
                    if ( COMPARISON_OPERATORS[type].hasOwnProperty(this.data.operator) ){
                        result = this.evaluators[type]( value, this.data.operator, with_value );
                    }
                }
            }
            return result;
        };

        if (
            object_has_keys_all(data, KEYS_NEEDED_TO_PARSE) && 
            Array.isArray(data.with) && data.with.length == 2  // with<array>[parameter_mode, parameter_value]
        ){
            this.data = data;
            var target_variable_id = safeInt(data.variable);
            if ( VARS.hasOwnProperty(target_variable_id) ){
                this.variable = VARS[data.variable];
            }
        } else {
            throw new Error( "Invalid Condition! Some of required data is missing: " + KEYS_NEEDED_TO_PARSE.join(", ") );
        }
        
    }
    
}

</script>
        <script>
/*./modules/content.js*/

// Arrow HTML-JS Runtime: Content node module

class Content {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {
        
        const _self = this;
        
        const DEFAULT_NODE_DATA = {
            "title": "",
            "content": "",
            "brief": 0,
            "auto": false,
            "clear": false,
        }

        // Forces auto-play regardless of the `auto` property
        const AUTO_PLAY_SLOT = -1;
        
        const CONTINUE_PLAY_SLOT = 0;
        
        const TITLE_TAG = "h2";
        const CONTENT_TAG = "pre";
        const BRIEF_TAG = "pre";

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = AUTO_PLAY_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            // a skipped content node is not displayed ...
            this.html.setAttribute('data-skipped', true);
            // ...  so there is no continue button and we shall play forward anyway
            this.play_forward_from((AUTO_PLAY_SLOT >= 0 ? AUTO_PLAY_SLOT : CONTINUE_PLAY_SLOT));
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.string_data_or_default = function(parameter) {
            var text = DEFAULT_NODE_DATA[parameter];
            if (
                this.node_resource.data.hasOwnProperty(parameter) &&
                (typeof this.node_resource.data[parameter] == 'string')
            ){
                text = this.node_resource.data[parameter]
            }
            return text;
        };
        
        this.bool_data_or_default = function(parameter) {
            var intended = DEFAULT_NODE_DATA[parameter];
            if (
                this.node_resource.data.hasOwnProperty(parameter) &&
                (typeof this.node_resource.data[parameter] == 'boolean')
            ){
                intended = this.node_resource.data[parameter]
            }
            return intended;
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {   
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else if (AUTO_PLAY_SLOT >= 0) {
                    this.play_forward_from(AUTO_PLAY_SLOT);
                } else {
                    if ( this.bool_data_or_default("auto") ) {
                        this.play_forward_from(CONTINUE_PLAY_SLOT);
                    }
                }
            }
            // View Clearance ?
            if (_ALLOW_CLEARANCE) {
                // `content` nodes can force the page to get cleaned before they step in
                if ( this.bool_data_or_default("clear") ) {
                    clear_up(this.node_id);
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ...
                    if ( node_resource.hasOwnProperty("data") ){
                        var title_string = this.string_data_or_default("title")
                        if ( title_string.length > 0 ){
                            this.title = create_element(TITLE_TAG, parse_bbcode( exposure( title_string ) ) );
                            this.html.appendChild(this.title);
                        }
                        // Textual (legacy) brief support:
                        // (It's not a string anymore so we can check for its default)
                        if ( node_resource.data.hasOwnProperty("brief") && typeof node_resource.data.brief == 'string' ){
                            this.brief = create_element(BRIEF_TAG, parse_bbcode( exposure( node_resource.data.brief ) ) );
                            this.html.appendChild(this.brief);
                        }
                        // ...
                        var content_string = this.string_data_or_default("content")
                        if (content_string.length > 0 ){
                            this.content = create_element(CONTENT_TAG, parse_bbcode( exposure( content_string ) ) );
                            this.html.appendChild(this.content);
                        }
                        if ( this.bool_data_or_default("auto") ) { this.html.setAttribute('data-auto', 'true'); }
                        if ( this.bool_data_or_default("clear") ) { this.html.setAttribute('data-clear', 'true'); }
                    }
                    // ...
                    this.continue_button = create_element("button", i18n("continue"));
                    this.continue_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, CONTINUE_PLAY_SLOT) );
                    this.html.appendChild(this.continue_button);
                    // ...
                    if (node_map.hasOwnProperty("skip") && node_map.skip === true) {
                        this.skip_button = create_element("button", i18n("skip"));
                        this.skip_button.addEventListener( _CLICK, this.skip_play.bind(_self) );
                        this.html.appendChild(this.skip_button);
                    }
            }
            return this;
        }
        throw new Error("Unable to construct `Content`");
    }
    
}

</script>
        <script>
/*./modules/dialog.js*/

// Arrow HTML-JS Runtime: Dialog node module

class Dialog {
    
    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        const ANONYMOUS_CHARACTER = {
            "name": i18n("dialog_anonymous_character_name"),
            "color": "ffffff",
        };

        const DEFAULT_NODE_DATA = {
            "character": -1, // ~ anonymous or unset (hardcoded convention)
            "lines": ["Hey there!"],
            // -- optional(s) --
            "playable": false,
        };

        const AUTO_PLAY_SLOT = -1;
        
        const LINES_HOLDER_TAG = 'ol';
        const LINE_ELEMENT_TAG = 'li';
        const PLAYED_LINE_TAG = 'p';
        
        this.lines = null;
        this.line_elements = null;
        this.played_line = null;
        this.character_profile = null;
        this.character_profile_element = null;
        this.character_name_element = null;

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = AUTO_PLAY_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // Plays the first *connected* slot (dialog) 
            // or just the first[0] slot if there is no connected one which means end edge
            var first_connected_slot = 0;
            if (this.slots_map.length >= 1) {
                var all_connected_slots = Object.keys(this.slots_map);
                all_connected_slots.sort();
                first_connected_slot = all_connected_slots[0];
            }
            this.play_forward_from(first_connected_slot);
        };
        
        this.set_view_played = function(slot_idx){
            // set the famous attribute,
            this.html.setAttribute('data-played', true);
            // then emphasize the played line
            if ( Number.isInteger(slot_idx) && slot_idx >= 0 && slot_idx < this.lines.length ){
                this.played_line = create_element(
                    PLAYED_LINE_TAG,
                    exposure(this.lines[slot_idx]),
                    { class: 'dialog-played-line' }
                );
                this.html.appendChild(this.played_line);
            } else {
                throw new Error("Unable to set `Dialog` played: The played slot doesn't exist: ", slot_idx);
            }
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
            // ... and remove the element for the emphasized played line
            if ( this.played_line ){
                this.played_line.remove();
                this.played_line = null;
            }
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                // handle skip in case,
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                // otherwise auto-play if set (which is not normal)
                } else if ( AUTO_PLAY_SLOT >= 0 ) {
                    this.play_forward_from(AUTO_PLAY_SLOT);
                // or handle the none-playable dialog in case ...
                } else {
                    this.random_play_none_playable_dialogs();
                }
                // ... and finally for normal playable dialogs,
                // we'll wait for the user to take action and play a line.
            }
        };

        this.create_line_elements = function(lines_array, lines_holder, listen){
            if ( ("appendChild" in lines_holder) == false ) lines_holder = null;
            var line_elements = [];
            for ( var idx = 0; idx < lines_array.length; idx++ ) {
                var line_element = create_element(
                    LINE_ELEMENT_TAG,
                    exposure(lines_array[idx])
                );
                if ( listen ){
                    // Each line has its own slot in the same order, so...
                    line_element.addEventListener(_CLICK, this.play_forward_from.bind(_self, idx));
                }
                if ( lines_holder ) lines_holder.appendChild(line_element);
                line_elements.push(line_element);
            }
            return line_elements;
        };
        
        this.has_intended_bool_behavior = function(parameter) {
            var is_intended = DEFAULT_NODE_DATA[parameter];
            if (
                this.node_resource.data.hasOwnProperty(parameter) &&
                (typeof this.node_resource.data[parameter] == 'boolean')
            ){
                is_intended = this.node_resource.data[parameter]
            }
            return is_intended;
        };
        
        this.random_play_none_playable_dialogs = function(){
            if ( this.has_intended_bool_behavior("playable") == false ){
                var random_played_line_idx = inclusiveRandInt( this.lines.length - 1);
                this.play_forward_from(random_played_line_idx);
            }
        };

        this.update_character_profile = function(character_id, character){
            if ( typeof character == 'object' && character.hasOwnProperty("color") && character.hasOwnProperty("name") ){
                if ( this.character_profile_element == null ){
                    this.character_name_element = create_element( "div", character.name, { class: 'character-name' } );
                    var data_attributes = {
                        class: 'character-profile',
                        style: `--character-color: #${character.color};`,
                        "data-id": character_id,
                        "data-name": character.name,
                    };
                    for (const key in character.tags){
                        data_attributes[`data-tag-${key}`] = character.tags[key];
                    };
                    this.character_profile_element = create_element( "div",
                        this.character_name_element,
                        data_attributes
                    );
                    this.html.appendChild(this.character_profile_element);
                } else {
                    this.character_profile_element.setAttribute('style', `--character-color: #${character.color};`);
                    this.character_name_element.innerHTML = character.name;
                }
            } else {
                if (_VERBOSE) console.error(character);
                throw new Error("Unable to Update Character Profile: Lack of required object keys, `name` and/or `color`.");
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    var error = null;
                    if ( node_resource.hasOwnProperty('data') ){
                        // Character profile:
                        if ( node_resource.data.hasOwnProperty('character') ){
                            var character_id = safeInt(node_resource.data.character);
                            this.update_character_profile(
                                character_id,
                                CHARS.hasOwnProperty(character_id) ? CHARS[character_id] : ANONYMOUS_CHARACTER,
                            );
                        }
                        // Lines:
                        if ( node_resource.data.hasOwnProperty('lines') && Array.isArray(node_resource.data.lines) && node_resource.data.lines.length > 0 ){
                            // + holder
                            this.lines_holder = create_element(LINES_HOLDER_TAG, null, { class: "dialog-lines"});
                                // + lines
                                this.lines = node_resource.data.lines;
                                this.line_elements = this.create_line_elements(node_resource.data.lines, this.lines_holder, true);
                            this.html.appendChild(this.lines_holder);
                        } else {
                            error = "No `lines` exist!";
                        }
                        if ( this.has_intended_bool_behavior("playable") ){
                            this.html.setAttribute('data-playable', 'true');
                        }
                    } else {
                        error = "The resource doesn't own the required `data`.";
                    }
                    if (error)  throw new Error("Unable to create `Dialog` node! " + error );

            }
            return this;
        }
        throw new Error("Unable to construct `Dialog`");
    }
    
}

</script>
        <script>
/*./modules/entry.js*/

// Arrow HTML-JS Runtime: Entry node module

class Entry {
    
    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        const AUTO_PLAY_SLOT = 0;
        
        this.get_element = function () {
            return this.html;
        };

        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = AUTO_PLAY_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // continue the only and natural path even if the node is skipped
            this.play_forward_from(AUTO_PLAY_SLOT);
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };

        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                // ... auto-plays anyway
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else if ( AUTO_PLAY_SLOT >= 0 ) {
                    this.play_forward_from(AUTO_PLAY_SLOT);
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    // + plaque:
                    if ( 
                        node_resource.hasOwnProperty("data") && node_resource.data.hasOwnProperty("plaque") &&
                        typeof node_resource.data.plaque == 'string' && node_resource.data.plaque.length > 0
                    ) {
                        this.plaque = create_element("em", node_resource.data.plaque, {'class': 'plaque'});
                        this.html.appendChild(this.plaque);
                    } else {
                        this.entry_mark = create_element("span", "[Entry]");
                        this.html.appendChild(this.entry_mark);
                    }
                    // + possible user interaction (manual play)
                    this.entry_button = create_element("button", node_resource.name);
                    this.entry_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, AUTO_PLAY_SLOT) );
                    this.html.appendChild(this.entry_button);
            }
            return this;
        }
        throw new Error("Unable to construct `Entry`");
    }

}

</script>
        <script>
/*./modules/frame.js*/

// Arrow HTML-JS Runtime: Frame node module

// NOTE:
//
// Frames nodes have no incoming or outgoing slots.
// They are designed to be used as visual organizers in the Arrow editor.
// Although frames can not act as active links in a plot and are not expected to be played by convention,
// they are structurally nodes (i.e. stored as node resources and allowed to be jumped into,)
// so shall have defined runtime behavior.
// This runtime treats them as end-of-line marker-like nodes (with labels) the same way the Arrow editor does.

class Frame {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        // super();

        const AUTO_PLAY_SLOT = 0;
        
        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = AUTO_PLAY_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                // NOTE:
                // You always end up here, because currently, **frames have no outgoing slot.**
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // continue the only and natural path even if the node is skipped
            this.play_forward_from(AUTO_PLAY_SLOT);
        };
        
        this.set_view_played = function(slot_idx){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play(); // ... also auto-plays forward
                } else if ( AUTO_PLAY_SLOT >= 0 ) {
                    this.play_forward_from(AUTO_PLAY_SLOT);
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    // Label
                    var label_text = (
                        node_resource.hasOwnProperty("data") && node_resource.data.hasOwnProperty("label") &&
                        typeof node_resource.data.label == 'string' && node_resource.data.label.length > 0
                    ) ? node_resource.data.label : "...";
                    var attributes = ( node_resource.data.hasOwnProperty("color") ? { style: `--frame-color: #${node_resource.data.color}; ` } :  undefined );
                    this.label = create_element("p", label_text, attributes);
                    this.html.appendChild(this.label);
                    // Manual play button
                    this.frame_button = create_element("button", node_resource.name);
                    this.frame_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, AUTO_PLAY_SLOT) );
                    this.html.appendChild(this.frame_button);
                // We also need to inform user in case there was a mistake in creating jumps and we ended up here,
                // because frames are not expected to be played!
                if (_VERBOSE) console.warn(
                    `We just hit a Frame node (${node_id} - ${node_resource.name})!\n` +
                    "Although this node type is not expected to be part of (or a link in) a plot, " +
                    "it is allowed to be played (by being jumped into,) so needs to have defined runtime behavior.\n" +
                    "Because there is no general outgoing scenario, this runtime treats frames as marker-like end-of-line nodes.\n" +
                    "Make sure this node is intentionally played and is not a misdirected jump.\n" +
                    "Better practice may be to use a `Marker` if you intend to get this kind of result.\n"
                )
            }
            return this;
        }
        throw new Error("Unable to construct `Frame`");
    }

}

</script>
        <script>
/*./modules/generator.js*/

// Arrow HTML-JS Runtime: Generator node module

class Generator {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        const ONLY_PLAY_SLOT = 0;
        
        const UNSET_EXPRESSION_MESSAGE = "Parameters unset or invalid!";
        const MAX_ARGS_PREVIEW_LENGTH = 10;

        const STRING_SET_DELIMITER = "|";
        const DEFAULT_CHARACTER_POOL = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz123456789";

        const VALID_GENERATORS = {
            "num": {
                "randi": {
                    "title": "Random Integer",
                    "func": function(args){
                        var result = null;
                        if (
                            Array.isArray(args) &&
                            args.length == 5
                        ){
                            if (
                                Number.isInteger(args[0]) && args[0] >= 0 &&
                                Number.isInteger(args[1]) && args[1] >= 2
                            ){
                                result = inclusiveRandInt(
                                    args[0],        // from
                                    (args[1] - 1), // to (exclusive)
                                    undefined,    // undefined base = 2
                                    args[2],     // negative,
                                    args[3],     // even
                                    args[4]     // odd
                                );
                            } else{
                                if (_VERBOSE) console.warn("Unexpected Behavior! Bad range for `randi` generator: ", args );
                            }
                        } else {
                            if (_VERBOSE) console.warn("Unexpected Behavior! Wrong arguments for `randi` generator: ", args );
                        }
                        if (result === null) {
                            result = inclusiveRandInt(0, 100); // so returns even on corrupt arguments
                        }
                        return result;
                    },
                    "args": function(data) {
                        if (data.hasOwnProperty("arguments") && Array.isArray(data.arguments) && data.arguments.length == 5){
                            var args = data.arguments;
                            return `: [${args[0]}, ${args[1]}] ${args[2] ? "N" : ""}${args[3] ? "E" : ""}${args[4] ? "O": ""}`;
                        } else {
                            return "(Invalid)"
                        }
                    },
                },
            },
            "str": {
                "ascii": {
                    "title": "Random ASCII String",
                    "func": function(args){
                        var result = "";
                        if (args.length == 2){
                            var char_pool = (typeof args[0] == "string" && args[0].length > 0) ? args[0] : DEFAULT_CHARACTER_POOL;
                            var char_pool_length = char_pool.length;
                            var desired_length = (typeof args[1] == "number" && args[1] >= 1) ? Math.floor(args[1]) : char_pool_length;
                            while (result.length < desired_length){
                                let char_pos = inclusiveRandInt(0, char_pool_length - 1);
                                console.log(char_pos);
                                result = ( result + char_pool[ char_pos ] );
                            }
                        }
                        return result;
                    },
                    "args": function(data) {
                        if (data.hasOwnProperty("arguments") && Array.isArray(data.arguments) && data.arguments.length == 2){
                            return `: ${data.arguments[1]} of \`${ellipsis(data.arguments[0].length > 0 ? data.arguments[0] : DEFAULT_CHARACTER_POOL, MAX_ARGS_PREVIEW_LENGTH)}\``;
                        } else {
                            return "(Invalid)"
                        }
                    },
                },
                "strst": {
                    "title": "From Set of Strings",
                    "func": function(stringified_set){
                        var result = "";
                        if (typeof stringified_set == "string" && stringified_set.length > 0){
                            var string_set = stringified_set
                                            .split(STRING_SET_DELIMITER)
                                            .filter( (part) => { return part.length > 0; } );
                            if (string_set.length > 0){
                                result = string_set[ inclusiveRandInt(0, (string_set.length - 1)) ];
                            }
                        }
                        return result;
                    },
                    "args": function(data) {
                        if (data.hasOwnProperty("arguments") && typeof data.arguments == 'string' && data.arguments.length > 0){
					        return ": `" + ellipsis(data.arguments, MAX_ARGS_PREVIEW_LENGTH) + "`"
                        } else {
                            return "(Null/Invalid)"
                        }
                    },
                },
            },
            "bool": {
                "rnbln": {
                    "title": "Random Boolean",
                    "func": function(_null){
                        return (
                            Math.floor( Math.random() * 10 ) % 2 == 0
                        );
                    },
                    "args": function(data) {
                        return "" // No arguments to preview
                    },
                },
            },
        };

        this.the_variable = null;
        this.the_variable_id = null;
        this.previous_variable_value = null;

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward = function(){
            if ( this.slots_map.hasOwnProperty(ONLY_PLAY_SLOT) ) {
                var next = this.slots_map[ONLY_PLAY_SLOT];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(ONLY_PLAY_SLOT);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // when skipped it *doesn't modify* the variable
            this.play_forward();
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            // reverse any variable update
            if ( this.the_variable && this.previous_variable_value !== null ){
                update_global_variable_by_id(this.the_variable_id, this.previous_variable_value);
            }
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };

        this.generate_and_play = function(){
            var new_value = null;
            if ( this.valid_generator ) {
                new_value = this.valid_generator.func.call(
                    null,
                    this.node_resource.data.hasOwnProperty("arguments") ? this.node_resource.data.arguments : null
                );
                // ... It may result in `null` (e.g. if the expression is unset.)
            }
            if ( new_value !== null && this.the_variable ){
                update_global_variable_by_id(this.the_variable_id, new_value);
                this.play_forward();
            } else {
                console.error(`Unable to run the generator (${this.node_resource.name}.) Skipped forward.`);
                this.skip_play();
            }
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else {
                    this.generate_and_play();
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Expression
                this.valid_generator = null;
                if ( this.node_resource.hasOwnProperty("data") && this.node_resource.data.hasOwnProperty("variable") ){
                    this.the_variable_id = safeInt(this.node_resource.data.variable);
                    if ( VARS.hasOwnProperty(this.the_variable_id) ) {
                        this.the_variable = VARS[ this.the_variable_id ];
                        this.previous_variable_value = this.the_variable.value;
                        if (
                            this.node_resource.data.hasOwnProperty("method") &&
                            this.the_variable.hasOwnProperty("type") &&
                            VALID_GENERATORS.hasOwnProperty(this.the_variable.type) &&
                            VALID_GENERATORS[this.the_variable.type].hasOwnProperty(this.node_resource.data.method)
                        ){
                            this.valid_generator = VALID_GENERATORS[this.the_variable.type][this.node_resource.data.method];
                        }
                    } else {
                        if (_VERBOSE) console.warn(
                            "Invalid Generator Node! The node has nonexistent UID as the target variable:",
                            this.the_variable_id,
                            this.node_resource
                        );
                    }
                } else {
                    if (_VERBOSE) console.warn(
                        "Invalid Generator Node! The node has no data set or target variable.",
                        this.node_resource
                    );
                }
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    // Parsed VariableUpdate Expression:
                    var parsed_valid_generator = (
                        this.valid_generator ?
                        `${this.the_variable.name} = ${this.valid_generator.title} ${this.valid_generator.args(this.node_resource.data)}`
                        : UNSET_EXPRESSION_MESSAGE
                    );
                    this.parsed_expression = create_element("code", parsed_valid_generator, { "class": "expression" });
                    this.html.appendChild(this.parsed_expression);
                    // Manual Evaluation Button:
                    this.eval_button = create_element("button", i18n("generate"));
                    this.eval_button.addEventListener( _CLICK, this.generate_and_play.bind(_self) );
                    this.html.appendChild(this.eval_button);
                    // and skip button (used in manual play and step-backs)
                    this.skip_button = create_element("button", i18n("skip"));
                    this.skip_button.addEventListener( _CLICK, this.skip_play.bind(_self) );
                    this.html.appendChild(this.skip_button);
            }
            return this;
        }
        throw new Error("Unable to construct `VariableUpdate`");
    }

}

</script>
        <script>
/*./modules/hub.js*/

// Arrow HTML-JS Runtime: Hub node module

class Hub {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;

        // Hubs are to merge edges,
        // so there is only one outgoing slot which is always auto-played
        const AUTO_PLAY_SLOT = 0;
        
        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = AUTO_PLAY_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // continue the only and natural path even if the node is skipped
            this.play_forward_from(AUTO_PLAY_SLOT);
        };
        
        this.set_view_played = function(slot_idx){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            // ditto
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else if ( AUTO_PLAY_SLOT >= 0 ) {
                    this.play_forward_from(AUTO_PLAY_SLOT);
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    this.hub_mark = create_element("span", "[Hub]");
                    this.html.appendChild(this.hub_mark);
                    this.hub_button = create_element("button", node_resource.name);
                    this.hub_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, AUTO_PLAY_SLOT) );
                    this.html.appendChild(this.hub_button);
            }
            return this;
        }
        throw new Error("Unable to construct `Hub`");
    }
    
}

</script>
        <script>
/*./modules/interaction.js*/

// Arrow HTML-JS Runtime: Interaction node module

class Interaction {
    
    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        const AUTO_PLAY_SLOT = -1;
        
        const ACTIONS_HOLDER_TAG = 'ol';
        const ACTION_ELEMENT_TAG = 'li';
        const PLAYED_ACTION_TAG = 'p';
        
        this.actions = null;
        this.action_elements = null;
        this.played_action = null;

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = AUTO_PLAY_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // Plays the first *connected* slot (interaction)
            // or just the first[0] slot if there is no connected one which means end edge
            var first_connected_slot = 0;
            if (this.slots_map.length >= 1) {
                var all_connected_slots = Object.keys(this.slots_map);
                all_connected_slots.sort();
                first_connected_slot = all_connected_slots[0];
            }
            this.play_forward_from(first_connected_slot);
        };
        
        this.set_view_played = function(slot_idx){
            // set the famous attribute,
            this.html.setAttribute('data-played', true);
            // then emphasize the played action
            if ( Number.isInteger(slot_idx) && slot_idx >= 0 && slot_idx < this.actions.length ){
                this.played_action = create_element(
                    PLAYED_ACTION_TAG,
                    exposure(this.actions[slot_idx]),
                    { class: 'interaction-played-action' }
                );
                this.html.appendChild(this.played_action);
            } else {
                throw new Error("Unable to set `Interaction` played: The played slot doesn't exist: ", slot_idx);
            }
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
            // ... and remove the element for the emphasized played action
            if ( this.played_action ){
                this.played_action.remove();
                this.played_action = null;
            }
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else if ( AUTO_PLAY_SLOT >= 0 ) {
                    this.play_forward_from(AUTO_PLAY_SLOT);
                }
            }
        };

        this.create_action_elements = function(actions_array, actions_holder, listen){
            if ( ("appendChild" in actions_holder) == false ) actions_holder = null;
            var action_elements = [];
            for ( var idx = 0; idx < actions_array.length; idx++ ) {
                var action_element = create_element(
                    ACTION_ELEMENT_TAG,
                    exposure(actions_array[idx])
                );
                if ( listen ){
                    // Each action has its own slot in the same order, so...
                    action_element.addEventListener(_CLICK, this.play_forward_from.bind(_self, idx));
                }
                if ( actions_holder ) actions_holder.appendChild(action_element);
                action_elements.push(action_element);
            }
            return action_elements;
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    var error = null;
                    if ( node_resource.hasOwnProperty('data') ){
                        // Actions:
                        if ( node_resource.data.hasOwnProperty('actions') && Array.isArray(node_resource.data.actions) && node_resource.data.actions.length > 0 ){
                            // + holder
                            this.actions_holder = create_element(ACTIONS_HOLDER_TAG, null, { class: 'interaction-actions' });
                                // + actions
                                this.actions = node_resource.data.actions;
                                this.action_elements = this.create_action_elements(node_resource.data.actions, this.actions_holder, true);
                            this.html.appendChild(this.actions_holder);
                        } else {
                            error = "No `actions` exist!";
                        }
                    } else {
                        error = "The resource doesn't own the required `data`.";
                    }
                    if (error)  throw new Error("Unable to create `Interaction` node! " + error );

            }
            return this;
        }
        throw new Error("Unable to construct `Interaction`");
    }
    
}

</script>
        <script>
/*./modules/jump.js*/

// Arrow HTML-JS Runtime: Jump node module

class Jump {
    
    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_the_jump = function(){
            if (this.node_resource.hasOwnProperty("data") && this.node_resource.data.hasOwnProperty("target") && Number.isInteger(this.node_resource.data.target) && this.node_resource.data.target >= 0 ){
                play_node(this.node_resource.data.target, 0);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played();
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // `jump`s have no default action when they are skipped
            handle_status(_CONSOLE_STATUS_CODE.NO_DEFAULT, _self);
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else {
                    this.play_forward_the_jump();
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                this.html.setAttribute('data-target',  node_resource.data.target);
                    // ... and the children
                    // Reason or a mark:
                    if (
                        node_resource.hasOwnProperty("data") && node_resource.data.hasOwnProperty("reason") &&
                        typeof node_resource.data.reason == 'string' && node_resource.data.reason.length > 0
                    ) {
                        this.reason = create_element("em", node_resource.data.reason, {'class': 'reason'});
                        this.html.appendChild(this.reason);
                    } else {
                        this.jump_mark = create_element("span", "[Jump]");
                        this.html.appendChild(this.jump_mark);
                    }
                    // Manual play button:
                    this.jump_button = create_element("button", `${node_resource.name} > ${node_resource.data.target}`);
                    this.jump_button.addEventListener( _CLICK, this.play_forward_the_jump.bind(_self) );
                    this.html.appendChild(this.jump_button);
            }
            return this;
        }
        throw new Error("Unable to construct `Jump`");
    }

}

</script>
        <script>
/*./modules/macro_use.js*/

// Arrow HTML-JS Runtime: Macro-Use node module

class MacroUse {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        this.holder = null;
        this.nodes_list = null;
        this.entry = null;

        const PLAY_FORWARD_SELF_SLOT =  0;
        
        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = PLAY_FORWARD_SELF_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            this.play_self_forward();
        };

        this.play_self_forward = function() {
            this.play_forward_from(PLAY_FORWARD_SELF_SLOT);
        };

        this.owns_node = function(node_id) {
            if ( this.nodes_list ){
                node_id = safeInt(node_id);
                return ( 
                    this.nodes_list.includes(node_id)
                );
            } else{
                if (_VERBOSE) console.warn("Unexpected Behavior! The `macro_use` instance has no valid `nodes_list`.");
            }
            return false;
        };

        this.append_instance = function(node_instance) {
            if (this.holder && 'appendChild' in this.holder){
                if ( 'get_element' in node_instance ){
                    this.holder.appendChild( node_instance.get_element() );
                    this.reset_replay(false); // we do not allow replaying macro in the midst (out of order)
                } else {
                    throw new Error("Invalid Instance! Unable to get_element from the inputted instance.");
                }
            } else {
                throw new Error("Unexpected Behavior! The holder element of the macro is not ready.");
            }
        };
        
        this.reset_replay = function(force) {
            if (this.replay) {
                var is_at_initial_state = (
                    typeof force == 'boolean' ? force :
                    this.holder.childElementCount == 0 && Number.isInteger(this.entry) && this.entry >= 0
                );
                this.replay.disabled = (! is_at_initial_state);
            } else {
                console.warn("Macro-use has no replay button!")
            }
        };

        this.set_view_played = function(slot_idx){
            this.html.setAttribute('data-played', true);
        };
        
        // IMPORTANT!
        // Unlike `step_back` which is called only when the node itself is the last step back,
        // this method could be called by the main runtime module whenever a wrapped node
        // (i.e. one inside the macro) is the last node (subject of backing;)
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        // This method is called when we `step_back` on a node that is wrapped by this macro_use
        this.step_into = function() {
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed()
        };

        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
            this.reset_replay();
        };

        this.replay_macro = function(){
            if ( Number.isInteger(this.entry) && this.entry >= 0 ){
                play_node(this.entry);
            } else {
                console.error(`Node ${this.node_id} using macro ${this.macro_id} has no valid entry: ${this.entry}`);
                this.skip_play();
            }
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                // handle skip in case,
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                // otherwise run the macro (i.e. scoped nodes starting with entry):
                } else {
                    this.replay_macro();
                }
            } else {
                this.reset_replay();
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // fetch the target macro and its map
                if ( node_resource.hasOwnProperty('data') && node_resource.data.hasOwnProperty('macro') ){
                    this.macro_id = safeInt( node_resource.data.macro );
                    if ( this.macro_id >= 0 ){
                        this.macro = get_resource_by_id(this.macro_id, 'scenes');
                        if ( this.macro ){
                            if ( this.macro.hasOwnProperty('map') && typeof this.macro.map == 'object' ){
                                this.nodes_list = Object.keys( this.macro.map ).map( safeInt );
                            }
                            if ( this.macro.hasOwnProperty("entry") ){
                                this.entry = safeInt(this.macro.entry);
                            }
                        } else {
                            throw new Error(`Corrupt Project Data! Node ${node_resource.name} (macro_use) links to no valid macro (scene) resource.`);
                        }
                    }
                }
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    this.html.setAttribute('data-macro',  node_resource.data.macro);
                    // holder element to capsulate sub-nodes
                    this.holder = create_element("div");
                    this.html.appendChild(this.holder);
                    // the identity label,
                    var macro_label = `${node_id}: ${node_resource.data.macro} - ${this.macro.name}`;
                    this.label = create_element("span", macro_label);
                    this.html.appendChild(this.label);
                    // a replay button
                    this.replay = create_element("button", macro_label);
                    this.replay.addEventListener( _CLICK, this.replay_macro.bind(_self) );
                    this.html.appendChild(this.replay);
                    // and skip button (used in manual play and step-backs)
                    this.skip_button = create_element("button", i18n("skip"));
                    this.skip_button.addEventListener( _CLICK, this.skip_play.bind(_self) );
                    this.html.appendChild(this.skip_button);
                // ...
                if ( Array.isArray(this.nodes_list) == false || this.nodes_list.length == 0 || this.nodes_list.includes(this.entry) == false ){
                    console.warn("Unset or invalid macro_use: ", node_id, node_resource, " -> Set to be skipped.");
                    this.node_map.skip = true;
                }
            }
            return this;
        }
        throw new Error("Unable to construct `MacroUse`");
    }
    
}

</script>
        <script>
/*./modules/marker.js*/

// Arrow HTML-JS Runtime: Marker node module

class Marker {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        // super();

        const AUTO_PLAY_SLOT = 0;
        
        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = AUTO_PLAY_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // continue the only and natural path even if the node is skipped
            this.play_forward_from(AUTO_PLAY_SLOT);
        };
        
        this.set_view_played = function(slot_idx){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play(); // ... also auto-plays forward
                } else if ( AUTO_PLAY_SLOT >= 0 ) {
                    this.play_forward_from(AUTO_PLAY_SLOT);
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    // Label
                    var label_text = (
                        node_resource.hasOwnProperty("data") && node_resource.data.hasOwnProperty("label") &&
                        typeof node_resource.data.label == 'string' && node_resource.data.label.length > 0
                    ) ? node_resource.data.label : "...";
                    var attributes = ( node_resource.data.hasOwnProperty("color") ? { style: `--marker-color: #${node_resource.data.color}; ` } :  undefined );
                    this.label = create_element("p", label_text, attributes);
                    this.html.appendChild(this.label);
                    // Manual play button
                    this.marker_button = create_element("button", node_resource.name);
                    this.marker_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, AUTO_PLAY_SLOT) );
                    this.html.appendChild(this.marker_button);
            }
            return this;
        }
        throw new Error("Unable to construct `Marker`");
    }

}

</script>
        <script>
/*./modules/monolog.js*/

// Arrow HTML-JS Runtime: Monolog node module

class Monolog {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {
        
        const _self = this;
        
        const DEFAULT_NODE_DATA = {
            "character": -1,
            "monolog": "",
            "brief": 0,
            "auto": false,
            "clear": false,
        }

        // Forces auto-play regardless of the `auto` property
        const AUTO_PLAY_SLOT = -1;
        
        const CONTINUE_PLAY_SLOT = 0;
        
        const MONOLOG_TAG = "pre";

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = AUTO_PLAY_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            // a skipped monolog node is not displayed ...
            this.html.setAttribute('data-skipped', true);
            // ...  so there is no continue button and we shall play forward anyway
            this.play_forward_from((AUTO_PLAY_SLOT >= 0 ? AUTO_PLAY_SLOT : CONTINUE_PLAY_SLOT));
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.string_data_or_default = function(parameter) {
            var text = DEFAULT_NODE_DATA[parameter];
            if (
                this.node_resource.data.hasOwnProperty(parameter) &&
                (typeof this.node_resource.data[parameter] == 'string')
            ){
                text = this.node_resource.data[parameter]
            }
            return text;
        };
        
        this.bool_data_or_default = function(parameter) {
            var intended = DEFAULT_NODE_DATA[parameter];
            if (
                this.node_resource.data.hasOwnProperty(parameter) &&
                (typeof this.node_resource.data[parameter] == 'boolean')
            ){
                intended = this.node_resource.data[parameter]
            }
            return intended;
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {   
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else if (AUTO_PLAY_SLOT >= 0) {
                    this.play_forward_from(AUTO_PLAY_SLOT);
                } else {
                    if ( this.bool_data_or_default("auto") ) {
                        this.play_forward_from(CONTINUE_PLAY_SLOT);
                    }
                }
            }
            // View Clearance ?
            if (_ALLOW_CLEARANCE) {
                // `monolog` nodes can force the page to get cleaned before they step in
                if ( this.bool_data_or_default("clear") ) {
                    clear_up(this.node_id);
                }
            }
        };

        this.update_character_profile = function(character_id, character){
            if ( typeof character == 'object' && character.hasOwnProperty("color") && character.hasOwnProperty("name") ){
                if ( this.character_profile_element == null ){
                    this.character_name_element = create_element( "div", character.name, { class: 'character-name' } );
                    var data_attributes = {
                        class: 'character-profile',
                        style: `--character-color: #${character.color};`,
                        "data-id": character_id,
                        "data-name": character.name,
                    };
                    for (const key in character.tags){
                        data_attributes[`data-tag-${key}`] = character.tags[key];
                    };
                    this.character_profile_element = create_element( "div",
                        this.character_name_element,
                        data_attributes
                    );
                    this.html.appendChild(this.character_profile_element);
                } else {
                    this.character_profile_element.setAttribute('style', `--character-color: #${character.color};`);
                    this.character_name_element.innerHTML = character.name;
                }
            } else {
                if (_VERBOSE) console.error(character);
                throw new Error("Unable to Update Character Profile: Lack of required object keys, `name` and/or `color`.");
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // Character
                    var character_id = safeInt(node_resource.data.character);
                    this.update_character_profile(
                        character_id,
                        CHARS.hasOwnProperty(character_id) ? CHARS[character_id] : ANONYMOUS_CHARACTER,
                    );
                    // Monolog
                    if ( node_resource.hasOwnProperty("data") ){
                        var monolog_string = this.string_data_or_default("monolog")
                        if (monolog_string.length > 0 ){
                            this.monolog = create_element(MONOLOG_TAG, parse_bbcode( exposure( monolog_string ) ) );
                            this.html.appendChild(this.monolog);
                        }
                        if ( this.bool_data_or_default("auto") ) { this.html.setAttribute('data-auto', 'true'); }
                        if ( this.bool_data_or_default("clear") ) { this.html.setAttribute('data-clear', 'true'); }
                    }
                    // ...
                    this.continue_button = create_element("button", i18n("continue"));
                    this.continue_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, CONTINUE_PLAY_SLOT) );
                    this.html.appendChild(this.continue_button);
                    // ...
                    if (node_map.hasOwnProperty("skip") && node_map.skip === true) {
                        this.skip_button = create_element("button", i18n("skip"));
                        this.skip_button.addEventListener( _CLICK, this.skip_play.bind(_self) );
                        this.html.appendChild(this.skip_button);
                    }
            }
            return this;
        }
        throw new Error("Unable to construct `Monolog`");
    }
    
}

</script>
        <script>
/*./modules/randomizer.js*/

// Arrow HTML-JS Runtime: Randomizer node module

class Randomizer {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;

        const AUTO_PLAY = true;
        const ONLY_USE_CONNECTED_SLOTS = false;
        
        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };

        this.play_forward_randomly = function(){
            var slots_count = -1;
            if ( ONLY_USE_CONNECTED_SLOTS !== true && this.node_resource.hasOwnProperty("data") && this.node_resource.data.hasOwnProperty("slots") ){
                slots_count = safeInt( this.node_resource.data.slots );
            }
            if ( slots_count < 0 ){
                slots_count = Object.keys(this.slots_map).length;
            }
            var random_out_slot_idx = inclusiveRandInt(0, (slots_count - 1) );
            this.play_forward_from(random_out_slot_idx);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // Randomizes anyway
            this.play_forward_randomly();
        };
        
        this.set_view_played = function(slot_idx){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                // Randomly play one of the outgoing slots
                // whether we are handling skip,
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                // or auto-playing
                } else if ( AUTO_PLAY ) {
                    this.play_forward_randomly();
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    this.rnd_mark = create_element("span", "[Randomizer]");
                    this.html.appendChild(this.rnd_mark);
                    this.randomizer_button = create_element("button", node_resource.name);
                    this.randomizer_button.addEventListener( _CLICK, this.play_forward_randomly.bind(_self) );
                    this.html.appendChild( this.randomizer_button );
            }
            return this;
        }
        throw new Error("Unable to construct `Randomizer`");
    }
    
}

</script>
        <script>
/*./modules/sequencer.js*/

// Arrow HTML-JS Runtime: Sequencer node module

class Sequencer {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;

        const AUTO_PLAY = true;
        
        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.count_slots = function() {
            var slots_count = -1;
            if (this.node_resource.hasOwnProperty("data") && this.node_resource.data.hasOwnProperty("slots") ){
                slots_count = safeInt( this.node_resource.data.slots );
            }
            if ( slots_count < 0 && typeof this.slots_map == 'object'){
                var connected_slot_keys_int = Object.keys(this.slots_map).map((x) => { return parseInt(x); }).sort((a, b) => { return a <= b; });
                slots_count = (connected_slot_keys_int ? connected_slot_keys_int.length > 0 : [-1])[0] + 1;
            }
            if (slots_count < 0) slots_count = 0;
            return slots_count;
        };

        this.request_play_forward = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            }
        };

        this.play_sequence_forward = function(){
            var nothing = true
            for (var slot_idx = 0; slot_idx < this.slots_count; slot_idx++){
                if ( this.slots_map.hasOwnProperty(slot_idx) ) { // (is connected)
                    nothing = false;
                    this.request_play_forward(slot_idx);
                }
            }
            if (nothing) {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played();
        };

        this.play_last_connected_slot = function(){
            var nothing = true
            for (var last_idx = (this.slots_count - 1); last_idx >= 0; last_idx--){
                if ( this.slots_map.hasOwnProperty(last_idx) ) { // (is connected)
                    nothing = false;
                    this.request_play_forward(last_idx);
                    break;
                }
            }
            if (nothing) {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played();
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            this.play_last_connected_slot();
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                // Play last connected slot if skipped
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                // or auto-playing all the sequence
                } else if ( AUTO_PLAY ) {
                    this.play_sequence_forward();
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                this.slots_count = this.count_slots();
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children including
                    // a marker
                    this.seq_mark = create_element("span", "[Sequencer]");
                    this.html.appendChild(this.seq_mark);
                    // play button
                    this.sequencer_button = create_element("button", node_resource.name);
                    this.sequencer_button.addEventListener( _CLICK, this.play_sequence_forward.bind(_self) );
                    this.html.appendChild( this.sequencer_button );
                    // and skip button (used in manual play and step-backs)
                    this.skip_button = create_element("button", i18n("skip"));
                    this.skip_button.addEventListener( _CLICK, this.skip_play.bind(_self) );
                    this.html.appendChild(this.skip_button);
                    // ...
                    this.set_view_unplayed()
            }
            return this;
        }
        throw new Error("Unable to construct `Sequencer`");
    }
    
}

</script>
        <script>
/*./modules/tag_edit.js*/

// Arrow HTML-JS Runtime: Tag-Edit node module

class TagEdit {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        const ONLY_PLAY_SLOT = 0;
        
        const METHODS = {
            0: "Inset",
            1: "Reset",
            2: "Overset",
            3: "Outset",
            4: "Unset",
        }

        this.the_character = null;
        this.the_character_id = null;
        this.the_character_tags_revert = null;

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward = function(){
            if ( this.slots_map.hasOwnProperty(ONLY_PLAY_SLOT) ) {
                var next = this.slots_map[ONLY_PLAY_SLOT];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(ONLY_PLAY_SLOT);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // when skipped it *doesn't modify* the character
            this.play_forward();
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            // reverse any character tag update
            if ( this.the_character && this.the_character_tags_revert !== null ){
                update_global_characters_tags(this.the_character_tags_revert);
                this.the_character_tags_revert = null;
            }
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };

        this.process_tag_edit_forward = function(){
            if ( this.the_character != null ){ // (~ means validity checks are passed)
		        var update_instruction = {};
                var revert_instruction = {};
                var current_tags = (
                    (this.the_character.hasOwnProperty("tags") && (typeof this.the_character.tags == 'object'))
                    ? this.the_character.tags : {}
                );
                var edit_key = this.node_resource.data.edit[1];
                var edit_value = this.node_resource.data.edit[2];
                switch (this.node_resource.data.edit[0]) {
                    case 0: // Inset: Adds a key:value tag, only if the key does not exist
                        if ( current_tags.hasOwnProperty(edit_key) == false ){
                            update_instruction[edit_key] = edit_value;
                            revert_instruction[edit_key] = null;
                        }
                        break;
                    case 1: // Reset: Updates value of a tag, only if the key exists
                        if (current_tags.hasOwnProperty(edit_key) == true){
                            update_instruction[edit_key] = edit_value;
                            revert_instruction[edit_key] = current_tags[edit_key];
                        }
                        break;
                    case 2: // Overset: Overwrites or adds a key:value tag, whether the key exists or not
                        update_instruction[edit_key] = edit_value;
                        revert_instruction[edit_key] = (
                            current_tags.hasOwnProperty(edit_key) ? current_tags[edit_key] : null
                        );
                        break;
                    case 3: // Outset: Removes a tag if both key & value match
                        if ( current_tags.hasOwnProperty(edit_key) == true ){
                            if (current_tags[edit_key] == edit_value) {
                                update_instruction[edit_key] = null;
                                revert_instruction[edit_key] = current_tags[edit_key];
                            }
                        }
                        break;
                    case 4: // Unset: Removes a tag if just the key matches
                        if (current_tags.hasOwnProperty(edit_key) == true){
                            update_instruction[edit_key] = null;
                            revert_instruction[edit_key] = current_tags[edit_key];
                        }
                        break;
                }
                // ...
                this.the_character_tags_revert = {}
                this.the_character_tags_revert[this.the_character_id] = revert_instruction;
                // ...
                var application = {};
                application[this.the_character_id] = update_instruction;
                update_global_characters_tags(application);
                // ...
                this.play_forward();
            } else {
                console.error(`Unable to process the tag-edit (${this.node_resource.name}.) Skipped forward.`);
                this.skip_play();
            }
        };

        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else {
                    this.process_tag_edit_forward();
                }
            }
        };
        
        this.data_is_valid = function(data){
            return (
                data != null && (typeof data == 'object') &&
                data.hasOwnProperty("character") && (Number.isInteger( safeInt(data.character) ) && safeInt(data.character) >= 0) &&
                data.hasOwnProperty("edit") && Array.isArray(data.edit) && data.edit.length >= 3 &&
                Number.isInteger(data.edit[0]) && METHODS.hasOwnProperty(data.edit[0]) &&
                (typeof data.edit[1] == 'string') && data.edit[1].length > 0 && (typeof data.edit[2] == 'string')
            )
        }
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // ...
                var is_valid = this.node_resource.hasOwnProperty("data") && this.data_is_valid(this.node_resource.data);
                if ( is_valid ){
                    this.the_character_id = safeInt(this.node_resource.data.character);
                    if ( CHARS.hasOwnProperty(this.the_character_id) ) {
                        this.the_character = CHARS[ this.the_character_id ];
                    } else {
                        is_valid = false
                        if (_VERBOSE) console.warn(
                            "Invalid Tag-Edit Node! The node has non-existent UID as the target character:",
                            this.the_character_id,
                            this.node_resource
                        );
                    }
                } else {
                    if (_VERBOSE) console.warn(
                        "Invalid Tag-Edit Node! The node has no valid data set or target character.",
                        this.node_resource
                    );
                }
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    if (is_valid) {
                        var edition = this.node_resource.data.edit
                        this.tag_edition = create_element("code",
                            `${this.the_character.name}.${edition[1]} << [${METHODS[edition[0]]}] '${edition[2]}'`,
                            {
                                style: `--character-color: #${this.the_character.color};`,
                                "data-character-id": this.the_character_id,
                                "data-character-name": this.the_character.name,
                            }
                        );
                        this.html.appendChild(this.tag_edition);
                    } else {
                        this.invalid_tag_edit = create_element("span", `[Tag-Edit] ${this.node_resource.name} : ${ i18n("invalid") }`);
                        this.html.appendChild(this.invalid_tag_edit);
                    }
                    // manual application button,
                    if (is_valid){
                        this.apply_button = create_element("button", i18n("apply"));
                        this.apply_button.addEventListener( _CLICK, this.process_tag_edit_forward.bind(_self) );
                        this.html.appendChild(this.apply_button);
                    }
                    // and skip button (used in manual play and step-backs)
                    this.skip_button = create_element("button", i18n("skip"));
                    this.skip_button.addEventListener( _CLICK, this.skip_play.bind(_self) );
                    this.html.appendChild(this.skip_button);
            }
            return this;
        }
        throw new Error("Unable to construct `VariableUpdate`");
    }

}

</script>
        <script>
/*./modules/tag_match.js*/

// Arrow HTML-JS Runtime: Tag-Match node module

class TagMatch {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;

        const AUTO_PLAY_SLOT = -1;

        this.the_character = null;
        this.the_character_id = null;
        this.tag_key = null;
        this.patterns = null;
        this.patterns_element = null;
        this.use_regex = false; // (current default)

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = safeInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 ){
                slot_idx = AUTO_PLAY_SLOT;
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // Plays the first *connected* slot (dialog) 
            // or just the first[0] slot if there is no connected one which means end edge
            var first_connected_slot = 0;
            if (this.slots_map.length >= 1) {
                var all_connected_slots = Object.keys(this.slots_map);
                all_connected_slots.sort();
                first_connected_slot = all_connected_slots[0];
            }
            this.play_forward_from(first_connected_slot);
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };

        this.play_manual = function() {
            if (this.patterns_element != null) {
                this.play_forward_from(this.patterns_element.selectedIndex)
            } else {
                this.play_forward_from(-1)
            }
        }

        this.process_tag_match_forward = function(){
            var matched = -1;
            if ( this.the_character != null && this.tag_key != null && this.patterns != null ){ // (~ means validity checks are passed)
                if (
                    this.the_character.hasOwnProperty("tags") && (typeof this.the_character.tags == 'object') &&
                    this.the_character.tags.hasOwnProperty(this.tag_key)
                ) {
                    var tag_value = this.the_character.tags[this.tag_key]
                    for (var i = 0; i <= this.patterns.length; i++) {
                        var pattern = this.patterns[i];
                        if (this.use_regex) {
                            try {
                                var regex = new RegExp(pattern);
                                if (tag_value.search(regex) >= 0) {
                                    matched = i;
                                    break;
                                }
                            } catch(err) {
                                if (_VERBOSE){
                                    console.warn(`Tag-Match RegExp pattern '${i}.${pattern}' failed: ` + err);
                                    console.warn(arguments);
                                }
                            }
                        } else {
                            if (pattern === tag_value){
                                matched == i;
                                break;
                            }
                        }
                    }
                }
            }
            if (matched >= 0) {
                this.patterns_element.selectedIndex = matched;
                console.log(`'${this.the_character.name}.${this.tag_key}' tag matched '${this.patterns[matched]}' pattern, branching to slot ${matched}`);
            }
            this.play_forward_from(matched);
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else {
                    this.process_tag_match_forward();
                }
            }
        };
        
        this.data_is_valid = function(data){
            return (
                data != null && (typeof data == 'object') &&
                data.hasOwnProperty("character") && (Number.isInteger( safeInt(data.character) ) && safeInt(data.character) >= 0) &&
                data.hasOwnProperty("patterns") && Array.isArray(data.patterns) && data.patterns.length > 0 &&
                data.hasOwnProperty("tag_key") && (typeof data.tag_key == 'string')
            )
        }
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // ...
                var is_valid = this.node_resource.hasOwnProperty("data") && this.data_is_valid(this.node_resource.data);
                if ( is_valid ){
                    this.the_character_id = safeInt(this.node_resource.data.character);
                    if ( CHARS.hasOwnProperty(this.the_character_id) ) {
                        this.the_character = CHARS[ this.the_character_id ];
                    } else {
                        is_valid = false
                        if (_VERBOSE) console.warn(
                            "Invalid Tag-Match Node! The node has non-existent UID as the target character:",
                            this.the_character_id,
                            this.node_resource
                        );
                    }
                    // ...
                    if (this.node_resource.data.hasOwnProperty("regex") && (typeof this.node_resource.data.regex == 'boolean')) {
                        this.use_regex = this.node_resource.data.regex;
                    }
                    // ...
                    this.tag_key = this.node_resource.data.tag_key;
                    this.patterns = this.node_resource.data.patterns;
                } else {
                    if (_VERBOSE) console.warn(
                        "Invalid Tag-Match Node! The node has no valid data set or target character.",
                        this.node_resource
                    );
                }
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    // Matching:
                    if (is_valid) {
                        this.patterns_element = create_element("select");
                        for (var i = 0; i < this.patterns.length; i++) {
                            var option = create_element("option", this.patterns[i]/*, { "value": this.patterns[i] }*/)
                            this.patterns_element.add(option)
                        }
                        this.character_tag = create_element(
                            "div",
                            `${this.the_character.name}.${this.tag_key}`,
                            {
                                style: `--character-color: #${this.the_character.color};`,
                                "data-character-id": this.the_character_id,
                                "data-character-name": this.the_character.name,
                            }
                        );
                        this.character_tag.appendChild(this.patterns_element);
                        this.html.appendChild(this.character_tag);
                    } else {
                        this.invalid_tag_pass = create_element("span", `[Tag-Match] ${this.node_resource.name} : ${ i18n("invalid") }`);
                        this.html.appendChild(this.invalid_tag_pass);
                    }
                    // EOL:
                    this.eol_button = create_element("button", i18n("eol"), { "value": "eol" });
                    this.eol_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, -1) );
                    this.html.appendChild(this.eol_button);
                    // MATCH:
                    this.match_button = create_element("button", i18n("match"), { "value": "match" });
                    this.match_button.addEventListener( _CLICK, this.play_manual.bind(_self) );
                    this.html.appendChild(this.match_button);
            }
            return this;
        }
        throw new Error("Unable to construct `TagMatch`");
    }

}

</script>
        <script>
/*./modules/tag_pass.js*/

// Arrow HTML-JS Runtime: Tag-Pass node module

class TagPass {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        const FALSE_SLOT = 0;
        const TRUE_SLOT  = 1;
        
        const METHODS = {
            0: "Any (OR)", // If at least one of the tags matches, it short-circuits and passes.
            1: "All (AND)", // All tags shall match for the node to pass.
        }

        this.the_character = null;
        this.the_character_id = null;

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward_from = function(slot_idx){
            slot_idx = parseInt(slot_idx);
            if ( Number.isFinite(slot_idx) == false || slot_idx < 0 || slot_idx > 1 ){
                // We default to `false` anytime something is wrong but we can continue
                slot_idx = FALSE_SLOT; 
            }
            if ( this.slots_map.hasOwnProperty(slot_idx) ) {
                var next = this.slots_map[slot_idx];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(slot_idx);
        };
        
        this.skip_play = function() {            
            // Skipped? The convention is to ...
            this.html.setAttribute('data-skipped', true);
            // ... react by playing the *False Slot First*
            if ( this.slots_map.hasOwnProperty(FALSE_SLOT) ){ // if false slot is connected
                this.play_forward_from(FALSE_SLOT);
            } else { // otherwise playing the *Only Remained [Possibly Connected] True Slot*
                this.play_forward_from(TRUE_SLOT); // which ...
            } // ... will naturally end the plot line if the true slot is not connected
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.tag_is_checkable = function(entity){
            return (
                Array.isArray(entity) && entity.length >= 1 && // at least a key
                (typeof entity[0] == 'string') && entity[0].length > 0 && // valid key
                (entity.length == 1 || entity[1] === null || (typeof entity[1] == 'string')) // valid value (including unchecked)
            )
        };

        this.process_tag_pass_forward = function(){
            var shall_pass = false;
            if ( this.the_character != null ){ // (~ means validity checks are passed)
                var current_tags = (
                    (this.the_character.hasOwnProperty("tags") && (typeof this.the_character.tags == 'object'))
                    ? this.the_character.tags : {}
                );
                var method = this.node_resource.data.pass[0];
                var checks = this.node_resource.data.pass[1];
                for (var i = 0; i < checks.length; i++){
                    var entity = checks[i];
                    if ( this.tag_is_checkable(entity) ){
                        shall_pass = (
                            current_tags.hasOwnProperty( entity[0] ) &&
                            ( entity.length == 1 || entity[1] == null || entity[1] == current_tags[entity[0]] )
                        );
                        if (method == 0 && shall_pass == true) break; // Any (OR) : short-circuits when reaches the first true
                        if (method == 1 && shall_pass == false) break; // All (AND) : breaks false if any one false is reached
                    }
                }
            }
            this.play_forward_from(
                (shall_pass == true) ? TRUE_SLOT : FALSE_SLOT
            );
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else {
                    this.process_tag_pass_forward();
                }
            }
        };
        
        this.data_is_valid = function(data){
            return (
                data != null && (typeof data == 'object') &&
                data.hasOwnProperty("character") && (Number.isInteger( safeInt(data.character) ) && safeInt(data.character) >= 0) &&
                data.hasOwnProperty("pass") && Array.isArray(data.pass) && data.pass.length >= 2 &&
                Number.isInteger(data.pass[0]) && METHODS.hasOwnProperty(data.pass[0]) && Array.isArray(data.pass[1])
		        // && Invalid tags are dropped/ignored, so we don't need to check deeper
            )
        }
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // ...
                var is_valid = this.node_resource.hasOwnProperty("data") && this.data_is_valid(this.node_resource.data);
                if ( is_valid ){
                    this.the_character_id = safeInt(this.node_resource.data.character);
                    if ( CHARS.hasOwnProperty(this.the_character_id) ) {
                        this.the_character = CHARS[ this.the_character_id ];
                    } else {
                        is_valid = false
                        if (_VERBOSE) console.warn(
                            "Invalid Tag-Pass Node! The node has non-existent UID as the target character:",
                            this.the_character_id,
                            this.node_resource
                        );
                    }
                } else {
                    if (_VERBOSE) console.warn(
                        "Invalid Tag-Pass Node! The node has no valid data set or target character.",
                        this.node_resource
                    );
                }
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    // Tags:
                    if (is_valid) {
                        var method = this.node_resource.data.pass[0];
                        var checks = this.node_resource.data.pass[1];
                        var checkable = 0;
                        var checkable_tags = create_element("div", `${this.the_character.name}: ${METHODS[method]}`);
                        for (var i = 0; i < checks.length; i++){
                            var entity = checks[i];
                            if (this.tag_is_checkable(entity)){
                                checkable += 1;
                                var checked_value = (entity.length >= 1 && (typeof entity[1] == 'string')) ? `'${entity[1]}'` : null;
                                checkable_tags.appendChild(
                                    create_element("span", `${ entity[0] }: ${ checked_value || "*" }`)
                                )
                            }
                        }
                        this.tag_passage = create_element("code",
                            ( checkable > 0 ? checkable_tags : `No Tags To Check` ),
                            {
                                style: `--character-color: #${this.the_character.color};`,
                                "data-character-id": this.the_character_id,
                                "data-character-name": this.the_character.name,
                            }
                        );
                        this.html.appendChild(this.tag_passage);
                    } else {
                        this.invalid_tag_pass = create_element("span", `[Tag-Pass] ${this.node_resource.name} : ${ i18n("invalid") }`);
                        this.html.appendChild(this.invalid_tag_pass);
                    }
                    // False:
                    this.false_button = create_element("button", i18n("false"), { "value": "false" });
                    this.false_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, FALSE_SLOT) );
                    this.html.appendChild(this.false_button);
                    // True:
                    this.true_button = create_element("button", i18n("true"), { "value": "true" });
                    this.true_button.addEventListener( _CLICK, this.play_forward_from.bind(_self, TRUE_SLOT) );
                    this.html.appendChild(this.true_button);
            }
            return this;
        }
        throw new Error("Unable to construct `TagPass`");
    }

}

</script>
        <script>
/*./modules/user_input.js*/

// Arrow HTML-JS Runtime: User-Input node module

class UserInput {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        this.the_variable_id = null;
        this.the_variable = null;
        this.previous_variable_value = null;

        const ONLY_PLAY_SLOT = 0;
        const INVALIDATE_EMPTY_STRING = false;

        const INPUT_LISTENER_EVENT  = 'input';

        const INPUT_PER_VARIABLE_TYPE = {
            'str': 'text',
            'num': 'number',
            'bool': 'checkbox'
        };

        const DEFAULT_INPUT_PROPERTIES = {
            "str": [undefined, "", ""],
            "num": [undefined, undefined, 1, 0],
            "bool": [ i18n('user_input_default_bool_negative'), i18n('user_input_default_bool_positive'), true],
        };

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };

        this.get_input_custom_properties = function() {
            return (
                (
                    this.node_resource.hasOwnProperty("data") &&
                    this.node_resource.data.hasOwnProperty("custom") &&
                    Array.isArray(this.node_resource.data.custom)
                ) ? this.node_resource.data.custom : []
            );
        };

        this.read_and_parse_value = function(){
            if (this.the_variable && this.input_element){
                switch ( this.the_variable.type ){
                    case 'str':
                        return this.input_element.value;
                    case 'num':
                        return safeInt(this.input_element.value, Number.NEGATIVE_INFINITY, true);
                    case 'bool':
                        return this.input_element.checked;
                }
            } else {
                throw new Error("Invalid Call! There is no variable or input element!");
            }
        };

        this.str_validator = function(){
            var is_valid = true;
            var value = this.read_and_parse_value();
            if ( INVALIDATE_EMPTY_STRING === true && value.length == 0 ){
                is_valid = false;
            } else {
                var custom = this.get_input_custom_properties();
                if (custom.length >= 1){
                    var pattern = custom[0];
                    if ( typeof pattern == 'string' ) {
                        if (pattern.length > 0){ // Blank patterns are ignored (pass everything)
                            var matches = value.match( new RegExp( pattern, "g" ) )
                            if (
                                Array.isArray(matches) == false || matches.length == 0 ||
                                matches[0] != value
                            ){
                                is_valid = false;
                            }
                        }
                    } else {
                        console.error(
                            this.node_id, "We can only accept RegExp strings as pattern.", this.node_resource
                        );
                        is_valid = false;
                    }
                }
            }
            return is_valid;
        };

        this.num_validator = function(){
            var is_valid = true;
            var value = this.read_and_parse_value();
            var error = undefined;
            if ( value == Number.NEGATIVE_INFINITY ){
                is_valid = false;
            } else {
                var custom = this.get_input_custom_properties();
                if (custom.length >= 3) {
                    for (var req = 0; req < 3; req++){
                        if (Number.isInteger(custom[req]) != true){
                            error = "All required values in custom for `num` [min, max, step, ...] shall be integers.";
                            is_valid = false;
                            break;
                        }
                    }
                    if (is_valid) { // (all integers, we can still proceed)
                        var min = custom[0], max = custom[1], step = custom[2];
                        if (min <= max) {
                            if (min == max) {
                                if (value != min) {
                                    is_valid = false;
                                }
                            } else { // ( min < max)
                                if (value < min || value > max) {
                                    is_valid = false;
                                } else { // is in range but is it stepped properly?
                                    if (step != 0 && ((value - min) % step) != 0) { // (zero step is ignored)
                                        is_valid = false;
                                    }
                                }
                            }
                        } else {
                            is_valid = false;
                            error = "`min` custom property shall be less or equal to `max`!";
                        }
                    }
                } else {
                    error = "We expect at least 3 numeral values [min, max, step, ...] to validate input.";
                    is_valid = false;
                }
            }
            if (error) { console.error(this.node_id, error, this.node_resource); };
            return is_valid;
        };

        this.bool_validator = function(){
            return ( typeof this.read_and_parse_value() == 'boolean' );
        };

        this.is_input_valid = function(){
            if (this.the_variable) {
                switch (this.the_variable.type) {
                    case 'str':
                        return this.str_validator();
                    case 'num':
                        return this.num_validator();
                    case 'bool':
                        return this.bool_validator();
                    default:
                        console.error(this.the_variable_id, this.the_variable)
                        throw new Error('Unsupported variable type!');
                }
            } else {
                // No variable (-1) can not be validated (strictly) and passes only on skip
                return false
            }
        };

        this.set_input_view = function() {
            if (this.the_variable) {
                var custom = this.get_input_custom_properties()
                var length = custom.length
                switch (this.the_variable.type) {
                    case 'str': // [pattern, default, extra]
                        const _STR_FIELDS = ["pattern", "value", "placeholder"]
                        for (var i = 0; i < _STR_FIELDS.length; i++) {
                            if (_STR_FIELDS[i] == "pattern" && custom[i].length == 0) {
                                // unlike html text input we consider blank string no enforced pattern,
                                // so we do not set the property; otherwise it would only accept blank strings.
                                continue;
                            };
                            if (_STR_FIELDS[i] != undefined) {
                                this.input_element[_STR_FIELDS[i]] = (
                                    length >= (i+1) && (typeof custom[i] == 'string')
                                    ? custom[i] : DEFAULT_INPUT_PROPERTIES["str"][i]
                                );
                            }
                        }
                        break;
                    case 'num': // [min, max, step, value]
                        const _NUM_FIELDS = ["min", "max", "step", "value"]
                        for (var i = 0; i < _NUM_FIELDS.length; i++) {
                            if (_NUM_FIELDS[i] != undefined) {
                                this.input_element[_NUM_FIELDS[i]] = (
                                    length >= (i+1) && Number.isInteger(custom[i]) ? custom[i] : DEFAULT_INPUT_PROPERTIES["num"][i]
                                );
                            }
                        }
                        break;
                    case 'bool': // [negative, positive, default-state]
                        this.input_element.checked = (length >= 3 ? custom[2] : DEFAULT_INPUT_PROPERTIES["bool"][2])
                        break;
                    default:
                        console.error(this.the_variable_id, this.the_variable)
                        throw new Error('Unsupported variable type!');
                }
                // and to apply:
                this.on_input_modification()
            } else {
                console.warn(`No variable is set for node ${this.node_id}`)
            }
        };

        this.reset_validity_state = function(force) {
            var validity = ((typeof force == 'boolean') ? force : this.is_input_valid());
            this.html.setAttribute('data-valid', validity);
            this.continue_button.disabled = (!validity)
        };

        this.on_input_modification = function() {
            this.reset_validity_state()
            // Switch boolean check-box label to current state as well:
            if (this.input_checkbox_label){
                var custom = this.get_input_custom_properties()
                var state_idx = (this.input_element.checked ? 1 : 0);
                this.input_checkbox_label.innerText = (
                    custom.length >= (state_idx + 1) && typeof custom[state_idx] == 'string'
                    ? custom[state_idx] : DEFAULT_INPUT_PROPERTIES["bool"][state_idx]
                )
            }
        };
        
        this.play_forward_from = function(_, skip){
            var valid = this.is_input_valid()
            if ( skip === true || valid == true ){
                if ( this.slots_map.hasOwnProperty( ONLY_PLAY_SLOT ) ) {
                    // update variable
                    if ( this.the_variable && valid && skip != true ){
                        update_global_variable_by_id( this.the_variable_id, this.read_and_parse_value() );
                    }
                    // then go for the next node
                    var next = this.slots_map[ONLY_PLAY_SLOT];
                    play_node(next.id, next.slot);
                } else {
                    handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
                }
                this.set_view_played(ONLY_PLAY_SLOT);
            } else {
                this.reset_validity_state(false)
            }
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            this.play_forward_from(ONLY_PLAY_SLOT, true);
        };
        
        this.set_view_played = function(slot_idx){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.set_input_view()
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            // reverse any variable update
            if ( this.the_variable && this.previous_variable_value !== null ){
                update_global_variable_by_id( this.the_variable_id, this.previous_variable_value );
            }
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                // `user_input` node type is pure interactive (there is no auto-play or default behavior,)
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    // if skipped, it means we just go to the next node as if this node didn't exist
                    this.skip_play();
                } // otherwise we shall wait for user interaction
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                // Sort stuff
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    var error = null;
                    if ( node_resource.hasOwnProperty('data') ){
                        // Prompt Message:
                        if ( node_resource.data.hasOwnProperty('prompt') ){
                            this.prompt_element = create_element("p", exposure(node_resource.data.prompt));
                            this.html.appendChild(this.prompt_element);
                        }
                        // Input
                        if ( node_resource.data.hasOwnProperty('variable') ){
                            this.the_variable_id = safeInt( node_resource.data.variable );
                            if ( VARS.hasOwnProperty( this.the_variable_id ) ){
                                this.the_variable = VARS[ this.the_variable_id ];
                                this.previous_variable_value = this.the_variable.value;
                                var input_html_type = INPUT_PER_VARIABLE_TYPE[ this.the_variable.type ];
                                var input_element_id = `${node_id}_input`;
                                this.input_element = create_element("input", null, {
                                    id: input_element_id,
                                    type: input_html_type
                                });
                                this.input_element.addEventListener( INPUT_LISTENER_EVENT, this.on_input_modification.bind(_self) );
                                this.html.appendChild(this.input_element);
                                if ( input_html_type == 'checkbox'){
                                    this.input_checkbox_label = create_element('label', null, {
                                        for: input_element_id
                                    });
                                    this.html.appendChild(this.input_checkbox_label);
                                }
                            } else {
                                error = "Invalid target variable id.";
                            }
                        }
                        // Continue Button
                        this.continue_button = create_element("button", i18n('continue'));
                        this.continue_button.addEventListener( _CLICK, this.play_forward_from.bind(_self) );
                        this.html.appendChild(this.continue_button);
                        // and skip button (used in manual play and step-backs)
                        this.skip_button = create_element("button", i18n("skip"));
                        this.skip_button.addEventListener( _CLICK, this.skip_play.bind(_self) );
                        this.html.appendChild(this.skip_button);
                        // ...
                        this.set_view_unplayed()
                    }
                    if ( error ) {
                        console.error(`Corrupt user_input node (${node_resource.name}) resource data: `, error, '\nNode set to be skipped.');
                        this.node_map.skip = true;
                    }
            }
            return this;
        }
        throw new Error("Unable to construct `UserInput`");
    }

}

</script>
        <script>
/*./modules/variable_update.js*/

// Arrow HTML-JS Runtime: Variable-Update node module

class VariableUpdate {

    constructor(node_id, node_resource, node_map, _playing_in_slot) {

        const _self = this;
        
        const ONLY_PLAY_SLOT = 0;
        
        const UNSET_EXPRESSION_MESSAGE = "Parameters unset or invalid!";

        this.the_variable = null;
        this.the_variable_id = null;
        this.previous_variable_value = null;

        this.get_element = function () {
            return this.html;
        };
        
        this.remove_element = function() {
            this.html.remove();
        };
        
        this.play_forward = function(){
            if ( this.slots_map.hasOwnProperty(ONLY_PLAY_SLOT) ) {
                var next = this.slots_map[ONLY_PLAY_SLOT];
                play_node(next.id, next.slot);
            } else {
                handle_status(_CONSOLE_STATUS_CODE.END_EDGE, _self);
            }
            this.set_view_played(ONLY_PLAY_SLOT);
        };
        
        this.skip_play = function() {
            this.html.setAttribute('data-skipped', true);
            // when skipped it *doesn't modify* the variable
            this.play_forward();
        };
        
        this.set_view_played = function(){
            this.html.setAttribute('data-played', true);
        };
        
        this.set_view_unplayed = function(){
            this.html.setAttribute('data-played', false);
        };
        
        this.step_back = function(){
            // reverse any variable update
            if ( this.the_variable && this.previous_variable_value !== null ){
                update_global_variable_by_id(this.the_variable_id, this.previous_variable_value);
            }
            this.html.setAttribute('data-skipped', false);
            this.set_view_unplayed();
        };

        this.evaluation_and_play = function(){
            var new_value = null;
            if ( this.update_expression ) {
                new_value = this.update_expression.evaluate();
                // ... It may result in `null` (e.g. if the expression is unset.)
            }
            if ( new_value !== null && this.the_variable ){
                update_global_variable_by_id(this.the_variable_id, new_value);
                this.play_forward();
            } else {
                console.error(`Unable to evaluate the variable_update (${this.node_resource.name}) expression. Skipped forward.`);
                this.skip_play();
            }
        };
        
        this.proceed = function(){
            if (_ALLOW_AUTO_PLAY) {
                if (this.node_map.hasOwnProperty("skip") && this.node_map.skip == true){
                    this.skip_play();
                } else {
                    this.evaluation_and_play();
                }
            }
        };
        
        if ( node_id >= 0 ){
            if ( typeof node_resource == 'object' && typeof node_map == 'object' ){
                this.node_id = node_id;
                this.node_resource = node_resource;
                this.node_map = node_map;
                this.slots_map = remap_connections_for_slots( (node_map || {}), node_id );
                // Expression
                this.update_expression = null;
                if ( this.node_resource.hasOwnProperty("data") && this.node_resource.data.hasOwnProperty("variable") ){
                    this.the_variable_id = safeInt(this.node_resource.data.variable);
                    try {
                        this.update_expression = new VariableUpdateExpression(this.node_resource.data, VARS);
                        this.the_variable = this.update_expression.variable;
                        this.previous_variable_value = this.the_variable.value;
                    } catch(err){
                        if (_VERBOSE) console.warn('Invalid Variable_Update Expression. Error:' + err);
                    }
                }
                // Create the node html element
                this.html = create_node_base_html(node_id, node_resource);
                    // ... and the children
                    // Parsed VariableUpdate Expression:
                    if ( this.update_expression ){
                        var parsed_update_expression = (this.update_expression.parse() || UNSET_EXPRESSION_MESSAGE);
                        this.parsed_expression = create_element("code", parsed_update_expression, {"class": "expression"});
                        this.html.appendChild(this.parsed_expression);
                    }
                    // Manual Evaluation Button:
                    this.eval_button = create_element("button", i18n("evaluate"));
                    this.eval_button.addEventListener( _CLICK, this.evaluation_and_play.bind(_self) );
                    this.html.appendChild(this.eval_button);
                    // and skip button (used in manual play and step-backs)
                    this.skip_button = create_element("button", i18n("skip"));
                    this.skip_button.addEventListener( _CLICK, this.skip_play.bind(_self) );
                    this.html.appendChild(this.skip_button);
                    // ...
            }
            return this;
        }
        throw new Error("Unable to construct `VariableUpdate`");
    }
}


class VariableUpdateExpression {
    
    constructor(data, variables){

        const _self = this;

        this.data = null;
        this.variable = null;

        const PARAMETER_MODES_ENUM = {
            0: "value",
            1: "variable"
        };
        const PARAMETER_MODES_ENUM_CODE = {
            "value": 0,
            "variable": 1
        };

        const UPDATE_OPERATORS = {
            "num": {
                "set": { "text": "Set Equal", "sign": "=" },
                "add": { "text": "Addition", "sign": "+=" },
                "sub": { "text": "Subtraction", "sign": "-=" },
                "div": { "text": "Division", "sign": "/=" },
                "rem": { "text": "Remainder", "sign": "%=" },
                "mul": { "text": "Multiplication", "sign": "*=" },
                "exp": { "text": "Exponentiation", "sign": "^=" },
                "abs": { "text": "Absolute", "sign": "=||" },
            },
            "str": {
                "set": { "text": "Set", "sign": "=" },
                "stc": { "text": "Set Capitalized", "sign": "C=" },
                "stl": { "text": "Set Lowercased", "sign": "l=" },
                "stu": { "text": "Set Uppercased", "sign": "U=" },
                "ins": { "text": "Insert Right", "sign": "=+" },
                "inb": { "text": "Insert Left", "sign": "+=" },
                "rmc": { "text": "Remove Left", "sign": "-=" },
                "rml": { "text": "Remove Left (Case Insensitive)", "sign": "-~" },
                "rmr": { "text": "Remove Right", "sign": "=-" },
                "rmi": { "text": "Remove Right (Case Insensitive)", "sign": "~-" },
                "rpl": { "text": "Replace", "sign": "=*" },
                "rpi": { "text": "Replace (Case Insensitive)", "sign": "~*" },
            },
            "bool": {
                "set": { "text": "Set", "sign": "=" },
                "neg": { "text": "Set Negative", "sign": "=!" },
            },
        };

        const KEYS_NEEDED_TO_PARSE = ["variable", "operator", "with"];
        
        const EXPRESSION_TEMPLATE = "{ident} {operator_sign} {parameter}";
        const UPDATED_WITH_SELF_INITIAL_RIGHT_SIDE = "Self (Intial Value)";
        
        const STRING_VALUE_FORMATING_TEMPLATE = "`%s`";
    
        this.parse = function(){
            var parsed = null;
            if ( this.variable && this.data ) {
                this.expression = { "ident": null, "operator_sign": null, "parameter": null };
                this.expression.ident = this.variable.name;
                if ( UPDATE_OPERATORS[this.variable.type].hasOwnProperty(this.data.operator) ){
                    this.expression.operator_sign = UPDATE_OPERATORS[this.variable.type][this.data.operator].sign;
                }
                switch ( this.data.with[0] ){
                    case PARAMETER_MODES_ENUM_CODE.value:
                        if (this.variable.type == "str"){
                            this.expression.parameter = STRING_VALUE_FORMATING_TEMPLATE.replace("%s", this.data.with[1]);
                        } else {
                            this.expression.parameter = this.data.with[1];
                        }
                        break;
                    case PARAMETER_MODES_ENUM_CODE.variable:
                        if ( this.data.with[1] == this.data.variable) { // the variable is compared to self (initial value)
                            this.expression.parameter = UPDATED_WITH_SELF_INITIAL_RIGHT_SIDE;
                        } else { // or another variable
                            if ( VARS.hasOwnProperty(this.data.with[1]) ) {
                                var parameter_var = VARS[ this.data.with[1] ];
                                this.expression.parameter = parameter_var.name;
                            }
                        }
                        break;
                }
                for (const key in this.expression) {
                    if ( this.expression.hasOwnProperty(key) ) {
                        if ( this.expression[key] === null ){
                            this.expression = null;
                            break;
                        }
                    }
                }
                parsed = (this.expression ? format(EXPRESSION_TEMPLATE, this.expression) : null );
            }
            return parsed;
        };
            
        this.evaluators = {
            "str": function(left, operation, right){ 
                var result = null;
                switch (operation) {
                    case "set": // Set (=)
                        result = right;
                        break;
                    case "stc": // Set Capitalized (C=)
                        result = capitalize(right);
                        break;
                    case "stl": // Set Lowercased (l=)
                        result = right.toLowerCase();
                        break;
                    case "stu": // Set Uppercased (u=)
                        result = right.toUpperCase();
                        break;
                    case "ins": // Insert Right (=+)
                        result = ( left + right );
                        break;
                    case "inb": // Insert Left (+=)
                        result = ( right + left );
                        break;
                    case "rmc": // Remove Left (-=)
                        var rem_idx = left.indexOf(right);
                        if (rem_idx >= 0){
                            result = left.substring(0, rem_idx) + left.substring(rem_idx + right.length);
                        } else {
                            result = left;
                        }
                        break;
                    case "rml": // Remove Left _Case Insensitive_ (-~)
                        var rem_idx = left.toLowerCase().indexOf(right.toLowerCase());
                        if (rem_idx >= 0){
                            result = left.substring(0, rem_idx) + left.substring(rem_idx + right.length);
                        } else {
                            result = left;
                        }
                        break;
                    case "rmr": // Remove Right (=-)
                        var rem_idx = left.lastIndexOf(right);
                        if (rem_idx >= 0){
                            result = left.substring(0, rem_idx) + left.substring(rem_idx + right.length);
                        } else {
                            result = left;
                        }
                        break;
                    case "rmi": // Remove Right _Case Insensitive_ (~-)
                        var rem_idx = left.toLowerCase().lastIndexOf(right.toLowerCase());
                        if (rem_idx >= 0){
                            result = left.substring(0, rem_idx) + left.substring(rem_idx + right.length);
                        } else {
                            result = left;
                        }
                        break;
                    case "rpl": // Replace (=*)	
                        var replacement = right.split("|");
                        if (replacement.length == 1){ replacement.push(""); }
                        result = left.replaceAll(replacement[0], replacement[1]);
                        break;
                    case "rpi": // Replace _Case Insensitive_ (~*)
                        var replacement = right.split("|");
                        if (replacement.length == 1){ replacement.push(""); }
                        var escaped_replacement = replacement[0].replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                        replacement[0] = new RegExp(escaped_replacement, 'ig');
                        result = left.replace(replacement[0], replacement[1]);
                        break;
                }
                return result;
            },
            "num": function(left, operation, right){
                var result = null;
                switch (operation) {
                    case "set": // Set Equal (=)
                        result = right;
                        break;
                    case "add": // Addition (+=)
                        result = (left + right);
                        break;
                    case "sub": // Subtraction (-=)
                        result = (left - right);
                        break;
                    case "div": // Division (/=)
                        result = Math.floor(left / right);
                        break;
                    case "rem": // Remainder (%=)
                        result = (left % right);
                        break;
                    case "mul": // Multiplication (*=)
                        result = (left * right);
                        break;
                    case "exp": // Exponentiation (^=)
                        result = Math.pow(left, right);
                        break;
                    case "abs": // Absolute (=||)
                        result = Math.abs(right);
                        break;
                }
                return ( Number.isFinite(result) ? Math.round(result) : null );
            },
            "bool": function(left, operation, right){
                var result = null;
                switch (operation){
                    case "set": // Set (=)
                        result = right;
                        break;
                    case "neg": // Set Negative (=!)
                        result = ( ! right );
                        break;
                }
                return result;
            }
        };

        this.evaluate = function(){
            var result = null;
            if ( this.variable ){
                var type  = this.variable.type;
                var value = this.variable.value;
                var with_value;
                switch ( this.data.with[0] ) {
                    case PARAMETER_MODES_ENUM_CODE.value:
                        with_value = this.data.with[1];
                        break;
                    case PARAMETER_MODES_ENUM_CODE.variable:
                        var the_second_variable_id = this.data.with[1];
                        if ( VARS.hasOwnProperty(the_second_variable_id) ){
                            if (the_second_variable_id == this.data.variable){
                                // with its own initial value
                                with_value = VARS[the_second_variable_id].init;
                            } else {
                                with_value = VARS[the_second_variable_id].value;
                            }
                        }
                        break;
                }
                if ( with_value !== null ) {
                    if ( type == "str" && ( typeof with_value != 'string') ){
                        with_value = with_value.toString();
                    } else if ( type == "num" && (typeof with_value != 'number') ){
                        with_value= safeInt(with_value, 0);
                    } else if ( type == "bool" && (typeof with_value != 'boolean') ){
                        with_value= safeBool(with_value);
                    }
                    if ( UPDATE_OPERATORS[type].hasOwnProperty(this.data.operator) ){
                        result = this.evaluators[type]( value, this.data.operator, with_value );
                    }
                }
            }
            return result;
        };

        if (
            object_has_keys_all(data, KEYS_NEEDED_TO_PARSE) && 
            Array.isArray(data.with) && data.with.length == 2  // with<array>[parameter_mode, parameter_value]
        ){
            this.data = data;
            var target_variable_id = safeInt(data.variable);
            if ( VARS.hasOwnProperty(target_variable_id) ){
                this.variable = VARS[data.variable];
            }
        } else {
            throw new Error( "Invalid VariableUpdate! Some of the required data is missing: " + KEYS_NEEDED_TO_PARSE.join(", ") );
        }
        
    }
    
}
</script>
        <script>
/*arrow.js*/

// Arrow HTML-JS Runtime: Main interpreter script

// Preferences
//
// NOTE: Respecting following preferences depends on each node module.
//

const _VERBOSE = true;    // console logging verbosity
const _CLICK   = 'click'; // default event to be listened for user interactions
const _LOCALE  = 'en';    // runtime's UI locale (used by `i18n`)

// This runtime allows nodes (such as hubs, generators, etc.)
// to auto-play (or skip) in case no user interaction is normally needed.
// You can force a fully manual play by disabling following constant.
// This constant controls auto-skipping as well.
const _ALLOW_AUTO_PLAY = true;

// Nodes (e.g. `Content`s) can clear up the view from all other nodes before them if allowed:
const _ALLOW_CLEARANCE = true;

const DO_NOT_PRINT_EOL_MESSAGE = true;

// Referencing to frequently used DOM Elements
var DOME = {};

// Global Variables
var VARS = {};

// Characters List
var CHARS = {};

var OPEN_NODES_BY_ORDER = [];
var OPEN_NODES_REFORMATTED_NAMES = []; // names-lowercased-with-whitespaces-replaced-by-dashes

if (typeof PROJECT != "object" || PROJECT.hasOwnProperty("entry") == false) {
    throw new Error("Invalid document data (i.e. `PROJECT` constant.)")
}

// Adjusting document to the project settings
const ROOT = document.getElementsByTagName('html')[0];

// Greeting
console.log(
    "Hello and welcome to \n\t" +
    PROJECT.title + "\n" +
    "Made with Arrow {{arrow_version}} \n" +
    "{{arrow_website}}"
);

const NODE_CLASSES_BY_TYPE = {
    // jshint ignore:start
    "condition": Condition,
    "content": Content,
    "dialog": Dialog,
    "entry": Entry,
    "frame": Frame,
    "generator": Generator,
    "hub": Hub,
    "interaction": Interaction,
    "jump": Jump,
    "macro_use": MacroUse,
    "marker": Marker,
    "monolog": Monolog,
    "randomizer": Randomizer,
    "sequencer": Sequencer,
    "tag_edit": TagEdit,
    "tag_match": TagMatch,
    "tag_pass": TagPass,
    "user_input": UserInput,
    "variable_update": VariableUpdate,
    // jshint ignore:end
};

const _CHARS_REQUIRED_KEYS = ["name", "color"];
function sort_characters(){
    var characters = PROJECT.resources.characters;
    for (const char_id in characters) {
        if ( characters.hasOwnProperty(char_id) ) {
            if ( object_has_keys_all( characters[char_id], _CHARS_REQUIRED_KEYS ) ){
                CHARS[char_id] = characters[char_id];
                if ( CHARS[char_id].hasOwnProperty("tags") == false ) {
                    CHARS[char_id].tags = {}
                }
            } else {
                throw new Error(`Unable to sort characters! The character '${char_id}' resource doesn't include required data! ${ _CHARS_REQUIRED_KEYS.join(", ") }`);
            }
        }
    }
}

function update_global_characters_tags(update_list) {
    for (char_id in update_list) {
        if ( CHARS.hasOwnProperty(char_id) ) {
            for (tag_key in update_list[char_id]) {
                if (tag_key.length > 0) {
                    var new_value = update_list[char_id][tag_key];
                    if (typeof new_value == 'string'){
                        console.log(`updating character tag '${tag_key} : ${CHARS[char_id].tags[tag_key]}' with '${new_value}' for '${CHARS[char_id].name}'`);
                        CHARS[char_id].tags[tag_key] = new_value;
                    } else if (new_value === null) {
                        if (CHARS[char_id].tags.hasOwnProperty(tag_key)) {
                            console.log(`removing character tag '${tag_key} : ${CHARS[char_id].tags[tag_key]}' for '${CHARS[char_id].name}'`);
                            delete CHARS[char_id].tags[tag_key];
                        }
                    } else {
                        console.warn(`Trying to update character tag '${tag_key}' with unexpected value: ${new_value}`, arguments);
                    }
                } else {
                    console.warn(`Trying to update character tag with blank key: ${tag_key}`, arguments);
                }
            }
        } else {
            console.warn(`Trying to update non-existent character ID: ${char_id}`, arguments);
        }
    }
}

const _GLOBAL_VARS_REQUIRED_KEYS = ["name", "type", "init"];
const _SUPPORTED_VARIABLE_TYPES  = ["num", "str", "bool"]; 
function sort_global_variables(){
    var variables = PROJECT.resources.variables;
    for (const var_id in variables) {
        if ( variables.hasOwnProperty(var_id) ) {
            if (
                object_has_keys_all( variables[var_id], _GLOBAL_VARS_REQUIRED_KEYS ) &&
                _SUPPORTED_VARIABLE_TYPES.includes( variables[var_id].type )
            ){
                VARS[var_id] = variables[var_id];
                VARS[var_id].value = variables[var_id].init; // Make it ready to change
                refresh_console_attribute_of(variables[var_id].name, VARS[var_id].value);
            } else {
                throw new Error(`Unable to sort global variables! The variable '${var_id}' resource doesn't include required data! ${ _GLOBAL_VARS_REQUIRED_KEYS.join(", ") }`);
            }
        }
    }
}

function update_global_variable_by_id(var_id, new_value){
    if ( VARS.hasOwnProperty(var_id) ){
        // Type checking...
        var var_type = VARS[var_id].type;
        if (
            ( var_type == 'str'  && typeof new_value == 'string'  ) ||
            ( var_type == 'num'  && Number.isInteger(new_value)   ) ||
            ( var_type == 'bool' && typeof new_value == 'boolean' )
        ) {
            // ... then updating
            var var_name = VARS[var_id].name;
            VARS[var_id].value = new_value;
            refresh_console_attribute_of(var_name, new_value);
            if (_VERBOSE) console.log("Variable Updated: ", var_name, "=", new_value);
        } else {
            throw new Error(`Unable to Update Global Variable! Type Inconsistency: new value ${new_value}<${typeof new_value}> for ${var_id}<${var_type}>`);
        }
    } else {
        throw new Error(`Unable to Update Global Variable by ID: No variable with ID '${var_id}'`);
    }
}

function update_global_variable_by_name(var_name, new_value){
    var var_uid = null
    for (const uid in VARS) {
        if ( VARS[uid].name === var_name ) {
            var_uid = uid;
            break;
        }
    }
    if ( var_uid !== null ){
        update_global_variable_by_id(var_uid, new_value);
    } else {
        throw new Error(`Unable to Update Global Variable by Name: No variable with name '${var_name}'`);
    }
}

function exposure(text){
    if ( typeof text == 'string' ){
        for (const var_id in VARS) {
            text = text.replaceAll(`{${VARS[var_id].name}}`, VARS[var_id].value);
        }
        for (const char_id in CHARS) {
            var char_name = CHARS[char_id].name;
            for (const tag_key in CHARS[char_id].tags){
                text = text.replaceAll(`{${char_name}.${tag_key}}`, CHARS[char_id].tags[tag_key]);
            }
        }
        return text;
    } else {
        throw new Error("Unable to process exposure: the text shall be of type string.");
    }
}

function refresh_console_attribute_of(var_name, new_value){
    DOME.CONSOLE.setAttribute( `data-${ escape_name(var_name) }`, ( typeof new_value == 'string' ? new_value : new_value.toString() ) );
}

// Project Validation
const PROJECT_DATA_MANDATORY_FIELDS = [ "title", "entry", "meta", "resources" ];
const PROJECT_DATA_RESOURCES_MANDATORY_SETS = [ "scenes", "nodes", "variables", "characters" ];
const DATASET_ITEM_MANDATORY_FIELDS_FOR_SET = {
    "scenes": [ "name", "entry", "map" ],
    "nodes": [ "type", "name", "data" ],
    "variables": [ "name", "type", "init" ],
    "characters": [ "name", "color" ]
};
function validate_project_data(project){
    if ( !project ) project = PROJECT;
    // Note: only essential validation (node type related checks shall be done by the respective module)
    if ( typeof project == 'object' ){
        if ( object_has_keys_all(project, PROJECT_DATA_MANDATORY_FIELDS ) ) {
            if ( object_has_keys_all(project.resources, PROJECT_DATA_RESOURCES_MANDATORY_SETS ) ){
                if (
                    Number.isInteger(project.entry) && project.resources.nodes.hasOwnProperty(project.entry)
                ){
                    for ( const set in project.resources ){
                        if ( project.resources.hasOwnProperty(set) ) {
                            for ( const uid in project.resources[set] ){
                                if ( project.resources[set].hasOwnProperty(uid) ){
                                    if (
                                        ( safeInt(uid, -1) < 0 ) ||
                                        ( typeof project.resources[set][uid] != 'object' ) ||
                                        ( object_has_keys_all( project.resources[set][uid], DATASET_ITEM_MANDATORY_FIELDS_FOR_SET[set] ) != true )
                                    ){
                                        // Doesn't pass general dataset checks
                                        return false;
                                    } else {
                                        // Passes? What about dataset special checks?
                                        switch (set){
                                            case "scenes":
                                                for ( const map_uid in project.resources[set][uid].map ){
                                                    if (
                                                        ( safeInt(map_uid, -1) < 0 ) ||
                                                        ( typeof project.resources[set][uid].map[map_uid] != 'object' ) /* ||
                                                        (
                                                            // A valid project requires valid offsets but,
                                                            // offsets are not required for this runtime to work. We can safely ignore them ...
                                                            project.resources[set][uid].map[map_uid].hasOwnProperty("offset") != true ||
                                                            Array.isArray(project.resources[set][uid].map[map_uid].offset) != true ||
                                                            project.resources[set][uid].map[map_uid].offset.length != 2 // [x, y]
                                                            )
                                                        */
                                                    ){
                                                        return false;
                                                    }
                                                }
                                                break;
                                            case "nodes":
                                                if ( typeof project.resources[set][uid].data != 'object'){
                                                    return false;
                                                }
                                                break;
                                            case "variables":
                                                // Nothing special at the time
                                                break;
                                            case "characters":
                                                // Ditto
                                                break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // Passes all
                    return true;
                }
            }
        }
    }
    // Passes none!
    return false;
}

function get_resource_by_id(res_id, priority_field) {
    var resource = null;
    // Optimization: Search in the priority_field first, where the resource most likely is
    // (defaults to `nodes`.)
    if ( typeof priority_field != "string" || priority_field.length == 0 || PROJECT.resources.hasOwnProperty(priority_field) == false ) priority_field = "nodes";
    if ( PROJECT.resources[priority_field].hasOwnProperty(res_id) ) {
        resource = PROJECT.resources[priority_field][res_id];
    } else {
        for (const field in PROJECT.resources) {
            if (PROJECT.resources.hasOwnProperty(field)) {
                if ( PROJECT.resources[field].hasOwnProperty(res_id) ){
                    resource = PROJECT.resources[field][res_id];
                }
            }
        }
    }
    return resource;
}

function get_owner_scene_of(node_id, only_return_scene_id){
    var scenes = PROJECT.resources.scenes;
    for (const scene_id in scenes) {
        if (scenes.hasOwnProperty(scene_id)) {
            if ( scenes[scene_id].map.hasOwnProperty(node_id) ){
                if ( only_return_scene_id === true ){
                    return scene_id;
                }
                return scenes[scene_id];
            }
        }
    }
    return null;
}

function get_node_map_by_id(node_id){
    var owner_scene = get_owner_scene_of(node_id);
    if (owner_scene){
        if ( owner_scene.hasOwnProperty("map") && owner_scene.map.hasOwnProperty(node_id) ){
         return owner_scene.map[node_id];   
        } else {
            return null;
        }
    } else {
        throw new Error(`Unable to get node (${node_id}) map: It belongs to no scene!`);
    }
}

function escape_name(name){
    if ( typeof name == 'string' && name.length > 0 ){
        return name.toLowerCase().replace(/\W/gi, "-");
    } else {
        throw new Error("Unable to scape the name. It must be a string longer than 0 chars.");
    }
}

function update_ui_open_nodes_list(new_child_name, clean_previous_ones){
    if (clean_previous_ones === true){
        OPEN_NODES_REFORMATTED_NAMES = [];
    }
    if (new_child_name && typeof new_child_name == 'string'){
        OPEN_NODES_REFORMATTED_NAMES.push( escape_name(new_child_name) );
    }
    DOME.CONTENT.setAttribute("data-open-nodes", OPEN_NODES_REFORMATTED_NAMES.join(' '));
}

// Clears view by removing all the appended nodes before the one with resource-uid passed as `the_last_one_id`.
function clear_up(the_last_one_id){
    var last_idx = 0;
    for(var l = OPEN_NODES_BY_ORDER.length - 1; l >= 0; l--){
        if ( OPEN_NODES_BY_ORDER[l].id == the_last_one_id ){
            last_idx = l;
            break;
        }
    }
    if ( last_idx > 0 ){
        OPEN_NODES_REFORMATTED_NAMES.splice(0, last_idx);
        var removed_ones = OPEN_NODES_BY_ORDER.splice(0, last_idx);
        for (var node of removed_ones) {
            node.instance.remove_element();
        }
        update_ui_open_nodes_list();
        if ( OPEN_NODES_BY_ORDER.length == 1){ // there is only one remained node!
            // make sure it's playable (Note: currently only content nodes clear up)
            OPEN_NODES_BY_ORDER[0].instance.step_back();
        }
    } else {
        throw new Error(`The annotated node (${the_last_one_id}) is not open or is the first one. We can only clean view from a node backward.`);
    }
}

function scroll_into_view(element){
    ( element || document.activeElement ).scrollIntoView({
        behavior: 'smooth',
        block: 'center',
        inline: 'center'
    });
}

var OPEN_MACRO = null;

function play_node(node_id, _playing_in_slot){
    var error, node_resource, node_map, instance;
    node_id = safeInt(node_id);
    _playing_in_slot = safeInt(_playing_in_slot);
    node_resource = get_resource_by_id(node_id);
    node_map = get_node_map_by_id(node_id);
    if ( node_id >= 0 ){
        if ( NODE_CLASSES_BY_TYPE.hasOwnProperty(node_resource.type) ){
            instance = new NODE_CLASSES_BY_TYPE[node_resource.type](
                node_id, node_resource, node_map, _playing_in_slot
            );
            // Macros need special treatments
            var handled_by_macro = false;
            if ( OPEN_MACRO ){
                if ( OPEN_MACRO.owns_node(node_id) ){
                    OPEN_MACRO.append_instance(instance);
                    handled_by_macro = true;
                } else { // We must have left the macro by jumping to a node outside, so ...
                    OPEN_MACRO.set_view_played();
                    OPEN_MACRO = null;
                }
            }
            OPEN_NODES_BY_ORDER.push({
                id: node_id,
                resource: node_resource,
                instance: instance,
                wrapper: OPEN_MACRO,
            });
            update_ui_open_nodes_list(node_resource.name);
            var new_node_element = instance.get_element();
            if (handled_by_macro == false) {
                DOME.CONTENT.appendChild( new_node_element );
            }
            // Is the new node itself a macro ?
            if ( node_resource.type == 'macro_use' ) OPEN_MACRO = instance;
            // Finally, proceed the node to auto-play, skip, etc.
            instance.proceed();
            scroll_into_view(new_node_element);
        } else {
            error = "Node Instancing Failed! The node type might be invalid.";
        }
    } else {
        error = "Invalid Node Resource!";
    }
    if (error){
        if (_VERBOSE) console.error(node_id, node_resource);
        throw new Error(error + ` Unable to play the node (${node_id}.)`);
    }
}

// More global constants
const _CONSOLE_STATUS_CODE = {
    "END_EDGE" : 0, // disconnected outgoing slot
	"NO_DEFAULT" : 1 // no default action is taken (e.g. due to being skipped)
};
function handle_status(status_code, the_player_node_instance){
    switch (status_code) {
        case _CONSOLE_STATUS_CODE.END_EDGE:
            if ( OPEN_MACRO && OPEN_MACRO != the_player_node_instance ){
                // This is most likely the end of a `macro_use` in a scene,
                // so there might be still more to play on the parent scene:
                OPEN_MACRO.play_self_forward();
            } else {
                var node_name = the_player_node_instance.node_resource.name;
                console.log(`EOL: ${node_name}`);
                if ( DO_NOT_PRINT_EOL_MESSAGE !== true ){
                    DOME.CONTENT.appendChild(
                        create_element(
                            'div',
                            format( i18n('eol_node'), { "node_name": node_name } ),
                            { class: 'eol' }
                        )
                    );
                }
            }
            break;
        case _CONSOLE_STATUS_CODE.NO_DEFAULT:
            if (_VERBOSE) {
                console.log(
                    `Node '${the_player_node_instance.node_resource.name}' has no action and no default!\n`+
                    'The node may be skipped or has unset/invalid parameters.'
                );
            }
            break;
    }
}

function play_back(steps, default_throw_error){
    var error = null;
    var open_nodes_count = OPEN_NODES_BY_ORDER.length;
    if ( open_nodes_count > 1 ){
        if ( Number.isInteger(steps) == false || steps < 1 || steps >= open_nodes_count ){
            steps = 1;
            if (_VERBOSE) console.warn("Unset or too many steps back. Reset to 1.");
        }
        // Now we step back
        var remove_threshold = ( open_nodes_count - steps );
        OPEN_NODES_REFORMATTED_NAMES.splice(remove_threshold);
        var removed_ones = OPEN_NODES_BY_ORDER.splice(remove_threshold);
        for (var node of removed_ones) {
            node.instance.remove_element();
        }
        update_ui_open_nodes_list();
        // we also need to make the last open node manually playable,
        var last = OPEN_NODES_BY_ORDER[ remove_threshold - 1 ];
        if ( last.wrapper != null ) {
            OPEN_MACRO = last.wrapper; // (with special cares)
            OPEN_MACRO.step_into();
        } else if (OPEN_MACRO != null && OPEN_MACRO.node_id != last.id){
            OPEN_MACRO.set_view_played();
            OPEN_MACRO = null;
        } else if ( last.resource.type == 'macro_use' ) {
            OPEN_MACRO = last.instance;
        }
        last.instance.step_back();
    } else {
        error = "There is only one remained open node! We can't step back anymore.";
    }
    if (error && default_throw_error != false) throw new Error(error);
}

var DARKMODE = false;
function switch_dark_mode(force){
    DARKMODE = ( typeof force === 'boolean' ? force : ( ! DARKMODE ) );
    ROOT.setAttribute( 'data-theme', ( DARKMODE ? 'dark' : 'light' ) );
    window.localStorage['_arrow_runtime_darkmode'] = DARKMODE; // jshint ignore: line
}

// Runtime
const runtime = function(){

    // Preparation
        // Making references for dry access
    DOME.CONSOLE = document.getElementById("console");
    DOME.CONTENT = document.getElementById("content");
        // Make sure _LOCALE is supported, otherwise stop running the project with an error
    if ( _SUPPORTED_LOCALES.includes(_LOCALE) == false ){
        throw new Error (`The set _LOCALE (${_LOCALE}) is not supported! To add a new one, edit i18n module.`);
    }
    // Then trying to run the project from its entry node
    var error_running = null;
    if ( typeof PROJECT == "object" && validate_project_data() === true ){
        sort_global_variables();
        sort_characters();
        play_node( PROJECT.entry );
        if (_VERBOSE) console.log(`Project Validation [OK]. Running from the project's entry node (${PROJECT.entry}) ...`);
    } else {
        error_running = "Project Data seems Corrupt !!";
    }
    if (error_running) throw new Error("Unable to Run the Project: " + error_running);

    // Control Buttons
    // Dark-mode
    try {
        const DARK_MODE_SWITCH = document.getElementById('switch-dark-mode');
        if ( DARK_MODE_SWITCH ) {
            DARK_MODE_SWITCH.addEventListener(_CLICK, switch_dark_mode);
            if ( window.localStorage && '_arrow_runtime_darkmode' in window.localStorage ){
                switch_dark_mode(
                    ( window.localStorage._arrow_runtime_darkmode === 'true' ||
                      window.localStorage._arrow_runtime_darkmode === true // really ?!
                    ) ? true : false
                );
            }
        }
    } catch (error){
        if (_VERBOSE) console.warn("Dark-mode is Not Available! The `#switch-dark-mode` button is missing.");
    }
    // Back
    try {
        const PLAY_BACK_BUTTON = document.getElementById('play-back');
        if ( PLAY_BACK_BUTTON ) {
            PLAY_BACK_BUTTON.addEventListener( _CLICK, play_back.bind(null, 1, false) );
        }
    } catch (error){
        if (_VERBOSE) console.warn("Play-Back is Not Available! The `#play-back` button is missing.");
    }

};

// Run the `runtime` function when the page is loaded
window.addEventListener("load", runtime);

</script>
        <style>
/*./arrow.css*/

/* Arrow HTML-JS Runtime: Main style sheet */

/* General */

/* General: Theme Color Schemes */
:root { /* light theme */
    --color-0: rgb(255, 255, 255);
    --color-1: rgb(249, 249, 250);
    --color-2: rgb(26, 0, 52);
    --color-3: rgb(0, 21, 41);
    --color-4: rgb(230, 230, 230);
    --color-5: rgb(0, 98, 128);
    --color-6: rgb(90, 90, 90);
    --color-7: rgb(170, 170, 170);
    --color-e: rgb(255, 0, 0);
}
:root[data-theme^='dark'] { /* dark theme */
    --color-0: rgb(0, 0, 0);
    --color-1: rgb(30, 30, 30);
    --color-2: rgb(255, 252, 222);
    --color-3: rgb(255, 206, 97);
    --color-4: rgb(49, 49, 49);
    --color-5: rgb(18, 226, 176);
    --color-6: rgb(181, 181, 181);
    --color-7: rgb(142, 117, 64);
    --color-e: rgb(255, 0, 0);
}

/* General: Normals */
:root {
    --font: monospace, sans-serif;
    font-family: var(--font);
    background-color: var(--color-1);
    color: var(--color-2);
    font-size: 16px;
    font-weight: 400;
    --font-weight-emphasis: 500;
    --font-weight-buttons: 700;
    --font-weight-buttons-secondary: 400;
    width: 100vw;
    line-height: 1.15; /* Correct the line height in all browsers */
    /* To prevent adjustments of font size after orientation changes in iOS : */
    /* -webkit-text-size-adjust: 100%; */
    --transition-time-medium: 0.5s;
    --border-width-normal: 1px;
    --border-color-normal: var(--color-4);
}
/* scrollbar */
:root{ /* firefox */
    scrollbar-color: var(--color-7) var(--color-4);
    scrollbar-width: auto; /* or `thin` ? */
}
/* chrome */
:root::-webkit-scrollbar {
    height: 100%;
    width: 0.75rem;
}
:root::-webkit-scrollbar-track-piece {
    background-color: var(--color-4);
}
:root::-webkit-scrollbar-thumb {
    background-color: var(--color-7);
}
body {
    padding: 0; margin: 0; /* reset */
    font-family: var(--font);
    width: 95vw;
    margin: 0 2.5vw;
    overflow-x: hidden;
    box-sizing: border-box;
    border: none; outline: none;
    padding: 0.25rem 1rem;
}
body > :first-child {
    margin-top: 1rem !important;
}
p, pre {
    overflow: visible;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    font-size: 1.124rem;
    line-height: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
    font-weight: normal;
    margin: 1em 0 0.1em 0;
}
h1 { font-size: 1.5em; }
h2 { font-size: 1.4em; }
h3 { font-size: 1.3em; }
h4 { font-size: 1.2em; }
h5 { font-size: 1.1em; }
h6 { font-size: 1.0em; }
a {
    color: var(--color-2);
    background-color: transparent;
    text-decoration: underline;
    cursor: pointer;
}
form, fieldset, div {
    width: 100%;
    box-sizing: border-box;
    border-color: var(--color-6);
    border-width: 1px;
    margin: 0.5rem 0;
}
input, button { /* normalize */
    overflow: visible;
    text-transform: none;
    font-family: inherit;
    font-size: 100%;
    line-height: 1.15;
    margin: 0;
}
input, button {
    margin: 0.25rem 0;
    box-sizing: content-box;
}
input, input::placeholder {
    font-family: var(--font);
}
input[type='text']::placeholder {
    color: var(--color-7);
}
input[type='text'], input[type='number'] {
    border: solid 2px var(--color-6);
    padding: 0.25rem 0.5rem;
    letter-spacing: 0.125rem;
    vertical-align: middle;
    border-radius: 0.25rem;
    text-align: center;
}
input[type='text'], input[type='number'], input[type='text']::placeholder {
    height: 2rem;
    font-size: 1rem;
}
input[type='text'], input[type='number'] {
    border-color: var(--color-4);
    background-color: var(--color-0);
    color: var(--color-3);
}
button, input[type='button'], input[type='submit'] {
    font-size: 1rem;
    font-weight: var(--font-weight-buttons);
    height: 1.75rem;
    padding: 0.25rem 0.75rem;
    border-radius: 0.25rem;
    border: none;
    background-color: var(--color-4);
    color: var(--color-5);
    cursor: pointer;
    outline: none;
}
button::-moz-focus-inner, button:active,
input[type='button']::-moz-focus-inner, input[type='button']:active,
input[type='submit']::-moz-focus-inner, input[type='submit']:active { /* reset */
    border-style: none;
    border: none;
    padding: 0.25rem 0.75rem;
    outline: none;
}
button:hover, input[type='button']:hover, input[type='submit']:hover {
    color: var(--color-3);
}
button:active, input[type='button']:active, input[type='submit']:active {
    color: var(--color-0);
    background-color: var(--color-5);
}
button:disabled {
    filter: grayscale(1) opacity(0.5);
}
textarea {
    display: block;
    width: 100%;
    height: 16vh;
    font-family: inherit;
    line-height: 1.15;
    font-size: 0.9rem;
    margin: 0.25rem 0;
    padding: 1rem;
    box-sizing: border-box;
    border: solid 1px var(--color-6);
    background-color: var(--color-0);
    color: var(--color-3);
    resize: vertical;
    margin-bottom: 0.75rem;
    overflow: auto; /* remove the default vertical scrollbar in IE 10+ */
}
fieldset {
    display: block;
    box-sizing: border-box;
    margin-top: 0.75rem;
    border-color: var(--color-6);
    padding: 0.35em 0.75em 0.625em; /* normalize */
}
legend {
    text-align: left;
    color: var(--color-6);
    box-sizing: border-box;
    display: table;
    max-width: 100%;
    font-size: 0.9em;
    padding: 0 0.25em;
    white-space: normal;
}
input[type="number"]::-webkit-outer-spin-button,
input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}
input[type="number"] {
    /* text-align: center; */
    -moz-appearance: textfield;
}
select {
    font-size: 1rem;
    background-color: var(--color-1);
    color: var(--color-2);
    font-family: var(--font);
}
em {
    font-style: italic;
}
u {
    text-decoration: underline;
}
strong {
    font-weight: bolder;
}

/* Header */

header {
    padding-bottom: 1rem;
    margin-bottom: 1rem;
    border-bottom: solid var(--border-width-normal) var(--border-color-normal);
}
header > h1 {
    font-size: 2.5rem;
    font-weight: 300;
    margin: 2rem 0;
}
header > h2 {
    font-size: 1.5rem;
    margin: 1.5rem 0;
    font-weight: 300;
}
header > h2 span {
    font-size: 0.75em;
    vertical-align: top;
}

/* Main */

main {}

#console { /* body > main > #console */
    /*
    You can style the content in the #console 
    based on the play's variables, i.e. `#console[data-<variable-name>] {}`
    e.g.
    `#console[data-health_state='critical'] { color: red; }`
    */
}

#content { /* body > main > #console > #content */
    /*
    Nodes are appended in this element with selectors resembling:
    `#content .node[data-name][data-type][data-uid]`
    with a `[data-played='true|false']` to indicate if they are played (automatically or by user interaction.)
    `#content` itself comes with `[data-open-nodes]`
    which is set to a list of space-separated node names (lowercased with whitespaces replaced by dashes.)
    */
}

/*
End-of-line (`.eol`) element is added automatically by the runtime (if `DO_NOT_PRINT_EOL_MESSAGE !== true`,)
whenever a sub-plot-line can not progress any further (i.e. no more nodes forward in that branch.)
*/
#content .eol {
    margin-top: 2rem;
    color: var(--color-7);
    /*
    On top of `DO_NOT_PRINT_EOL_MESSAGE` constant in `arrow.js` file,
    you can uncomment following line if you don't want any end message.
    */
    /* display: none; */
}

/* Footer */

footer {
    border-top: solid var(--border-width-normal) var(--border-color-normal);
    font-size: 0.8rem;
    margin-top: 5rem;
    margin-bottom:5rem;
    padding-top: 0.25em;
    /* text-align: center; */
}
footer a {
    color: var(--color-3);
    text-decoration: none;
}
footer a:hover {
    color: var(--color-5);
}
footer a:active{
    color: var(--color-3);
}
footer p {
    font-size: 0.9rem;
    padding: 0.25em 0;
    margin: 0;
}
footer p:first-of-type {
    margin-top: 1rem;
}
footer button:not(:first-of-type) {
    margin: 0 0.5rem;
}

/* ---------- */
/* Node Types */
/* ---------- */

.node {
    --shown-skipped-node-opacity: 0.7;
    /* General node transition */
    transition: filter var(--transition-time-medium) ease-in-out;
}

.node[data-skipped='true'] > *:not(button) {
    filter: opacity( var(--shown-skipped-node-opacity) );
}

/* HINT: You can remove this block if you want to display skipped nodes anyway */
.node[data-played='true'][data-skipped='true'] {
    display: none;
}

/* content */
.node[data-type='content'] {
    /* It may come with [data-auto='true'] or [data-clear='true'] */
}
.node[data-type='content'] button { /* both buttons */
    margin: 0.25rem;
}
.node[data-type='content'][data-played='true'] button {
    display: none;
}

/* condition */
.node[data-type='condition'] {}
.node[data-type='condition'][data-played='true'] {
    display: none;
}
.node[data-type='condition'] /*code*/.statement {}
.node[data-type='condition'] button {
    margin: 0.5rem;
}

/* dialog */
.node[data-type='dialog'] {
    /* It may come with [data-playable='true'] when it's intended to be manually playable by user */
}
.node[data-type='dialog'] /*div*/.character-profile {
    /*
    It comes with `[data-name]` and `[data-id]`, set to the character's name (unescaped) and UID,
    and `--character-color: #<character-hex-color>;` css variable set inline.
    It can also have `[data-tag-<key>='<value>']` attribute for each existent tag.
    */
}
.node[data-type='dialog'] /*div.character-profile*/.character-name {
    word-break: break-all;
}
.node[data-type='dialog'] /*div.character-profile*/.character-name::before {
    content: "";
    display: inline-block;
    width: 0.75rem;
    height: 0.75rem;
    vertical-align: middle;
    margin: 0.5rem;
    border: solid 0.125rem var(--color-7);
    transform: translateY( calc( -0.125rem / 2 ) );
    border-radius: 100%;
    background-color: var(--character-color);
}
.node[data-type='dialog'] /*div.character-profile*/.character-name::after {
    content: ":";
}
.node[data-type='dialog'] /*ol*/.dialog-lines {
    list-style: none;
    padding: 0;
    margin: 0;
}
.node[data-type='dialog'] /*ol*/.dialog-lines li { /* each line */
    margin: 0.5rem 2rem;
    border-left: dashed 0.125rem var(--color-5);
    padding-left: 1rem;
    cursor: pointer;
    font-weight: var(--font-weight-buttons);
    text-decoration: underline;
    font-size: 1.125em;
}
.node[data-type='dialog'] /*ol*/.dialog-lines li:hover {
    color: var(--color-5);
}
.node[data-type='dialog'] /*p*/.dialog-played-line {
    font-size: 1.1em;
    font-weight: var(--font-weight-emphasis);
    border-left: solid 0.125rem var(--color-6);
    padding: 0.75em;
    margin: 0.5rem 2rem;
}
.node[data-type='dialog'][data-played='true'] .dialog-lines {
    display: none;
}

/* entry */
.node[data-type='entry'] {}
.node[data-type='entry'][data-played='true'] {
    display: none;
}
.node[data-type='entry'] /*em*/.plaque {}
.node[data-type='entry'] span { /* (Entry mark if no plaque is set) */ }
.node[data-type='entry'] button {
    margin: 0.75rem;
}

/* frame */
.node[data-type='frame'] {}
.node[data-type='frame'] p {
    /* The frame label. `--frame-color` is set inline. */
    color: var(--frame-color);
    border: solid 0.125rem var(--frame-color);
    border-radius: 1rem;
    display: inline-block;
    padding: 0.25rem 0.5rem;

}
.node[data-type='frame'] button {
    margin: 0.5rem;
}
.node[data-type='frame'][data-played='true'] p {
    filter: opacity( 0.5 );
}
.node[data-type='frame'][data-played='true'] button {
    display: none;
}

/* generator */
.node[data-type='generator'] {}
.node[data-type='generator'][data-played='true'] {
    display: none;
}
.node[data-type='generator'] /*code*/.expression {}
.node[data-type='generator'] button {
    margin: 0.5rem;
}

/* hub */
.node[data-type='hub'] {}
.node[data-type='hub'][data-played='true'] {
    display: none;
}
.node[data-type='hub'] span { /* (Hub mark) */ }
.node[data-type='hub'] button {
    margin: 0.75rem;
}

/* interaction */
.node[data-type='interaction'] {}
.node[data-type='interaction'] /*ol*/.interaction-actions {
    list-style: none;
    padding: 0;
    margin: 0;
}
.node[data-type='interaction'] /*ol*/.interaction-actions li { /* each line */
    margin: 0.5rem 0;
    border-left: dashed 0.125rem var(--color-5);
    padding-left: 1rem;
    cursor: pointer;
    font-weight: var(--font-weight-buttons);
    text-decoration: underline;
    font-size: 1.125em;
}
.node[data-type='interaction'] /*ol*/.interaction-actions li:hover {
    color: var(--color-5);
}
.node[data-type='interaction'] /*p*/.interaction-played-action {
    font-size: 1.1em;
    font-weight: var(--font-weight-emphasis);
    border-left: solid 0.125rem var(--color-6);
    padding: 0.75em;
    margin: 0.5rem 0;
}
.node[data-type='interaction'][data-played='true'] .interaction-actions {
    display: none;
}

/* jump */
.node[data-type='jump'] {
    /* It comes with `[data-target]` set to the destination node's UID. */
}
.node[data-type='jump'][data-played='true'] {
    display: none;
}
.node[data-type='jump'] /*em*/.reason {}
.node[data-type='jump'] span { /* (Jump mark if no reason is set) */ }
.node[data-type='jump'] button {
    margin: 0.75rem;
}

/* macro_use */
.node[data-type='macro_use'] {
    /* It also comes with `[data-macro]` set to the UID of the used macro */
    position: relative;
    border: dashed 0.125rem var(--color-4);
    padding: 2rem;
}
.node[data-type='macro_use'] > span { /* macro label */
    position: absolute;
    top: -0.125rem;
    right: -0.125rem;
    border-bottom-left-radius: 0.5rem;
    padding: 0.25rem 0.5rem;
    background: var(--color-4);
    color: var(--color-6);
    word-break: break-all;
}
.node[data-type='macro_use'] > button:nth-of-type(1) { /* replay */ }
.node[data-type='macro_use'] > button:nth-of-type(1):disabled {
    display: none;
}
.node[data-type='macro_use'] > button:nth-of-type(2) { /* skip */
    position: absolute;
    bottom: -0.125rem;
    right: -0.125rem;
    margin: 0;
}
.node[data-type='macro_use'][data-played='true'] > button {
    display: none;
}

/* marker */
.node[data-type='marker'] {}
.node[data-type='marker'] p { /* (The marker label) */
    /* `--marker-color` is set inline. */
    color: var(--marker-color);
    border: solid 0.125rem var(--marker-color);
    border-radius: 1rem;
    display: inline-block;
    padding: 0.25rem 1rem;
    
}
.node[data-type='marker'] button {
    margin: 0.5rem;
}
.node[data-type='marker'][data-played='true'] p {
    filter: opacity( 0.5 );
}
.node[data-type='marker'][data-played='true'] button {
    display: none;
}
/* [data-theme^='dark'] .node[data-type='marker'] { filter: invert(1); } */

/* monolog */
.node[data-type='monolog'] {
    /* It may come with [data-auto='true'] or [data-clear='true'] */
}
.node[data-type='monolog'] /*div*/.character-profile {
    /*
    It comes with `[data-name]` and `[data-id]`, set to the character's name (unescaped) and UID,
    and `--character-color: #<character-hex-color>;` css variable set inline.
    It can also have `[data-tag-<key>='<value>']` attribute for each existent tag.
    */
}
.node[data-type='monolog'] /*div.character-profile*/.character-name {
    word-break: break-all;
}
.node[data-type='monolog'] /*div.character-profile*/.character-name::before {
    content: "";
    display: inline-block;
    width: 0.75rem;
    height: 0.75rem;
    vertical-align: middle;
    margin: 0.5rem;
    border: solid 0.125rem var(--color-7);
    transform: translateY( calc( -0.125rem / 2 ) );
    border-radius: 100%;
    background-color: var(--character-color);
}
.node[data-type='monolog'] /*div.character-profile*/.character-name::after {
    content: ":";
}
.node[data-type='monolog'] pre { /* (the monolog) */
    font-size: 1.1em;
    font-weight: var(--font-weight-emphasis);
    border-left: solid 0.125rem var(--color-6);
    padding: 0.75em;
    margin: 0.5rem 2rem;
}
.node[data-type='monolog'] button { /* both buttons */
    margin: 0.25rem;
}
.node[data-type='monolog'][data-played='true'] button {
    display: none;
}

/* randomizer */
.node[data-type='randomizer'] {}
.node[data-type='randomizer'][data-played='true'] {
    display: none;
}
.node[data-type='randomizer'] span { /* (Randomizer mark) */ }
.node[data-type='randomizer'] button {
    margin: 0.75rem;
}

/* sequencer */
.node[data-type='sequencer'] {}
.node[data-type='sequencer'][data-played='true'] {
    display: none;
}
.node[data-type='sequencer'] span { /* (Sequencer mark) */ }
.node[data-type='sequencer'] button { /* both skip and play buttons */
    margin: 0.75rem;
}

/* tag_edit */
.node[data-type='tag_edit'] {}
.node[data-type='tag_edit'][data-played='true'] {
    display: none;
}
.node[data-type='tag_edit'] > code { /* (valid) */
    /* The target character color `--character-color` is set inline. */
    /* It also comes with `[data-character-id]` and `[data-character-name]` as well */
    display: inline-block;
    padding: 0.5rem 1rem;
    margin-bottom: 0.5rem;
    border: solid 0.125rem var(--character-color);
    border-left-width: 1.5rem;
    border-top-right-radius: 0.125rem;
    border-bottom-right-radius: 0.125rem;
    /* color: var(--character-color); */
    margin-inline-end: 0.75rem;
    word-break: break-all;
}
.node[data-type='tag_edit'] > span { /* (invalid) */
    display: inline-block;
    margin-inline-end: 0.75rem;
    margin-bottom: 0.5rem;
}
.node[data-type='tag_edit'] button { /* both skip and apply */
    margin: 0.25rem;
}

/* tag_match */
.node[data-type='tag_match'] {}
.node[data-type='tag_match'] > span { /* (invalid) */
    display: inline-block;
    margin-bottom: 0.5rem;
    margin-inline-end: 0.75rem;
}
.node[data-type='tag_match'][data-played='true'] {
    display: none;
}
.node[data-type='tag_match'] > div {
    /* The target character color `--character-color` is set inline. */
    /* It also comes with `[data-character-id]` and `[data-character-name]` as well */
    display: inline;
    padding: 0.5rem 1rem;
    margin-bottom: 0.5rem;
    border: dashed 0.125rem var(--character-color);
    border-left-width: 1.5rem;
    border-left-style: solid;
    margin-inline-end: 0.75rem;
    word-break: break-all;
}
.node[data-type='tag_match'] > div > select {
    margin-left: 1rem;
}
.node[data-type='tag_match'] button { /* both skip and apply */
    margin: 0.25rem;
}

/* tag_pass */
.node[data-type='tag_pass'] {}
.node[data-type='tag_pass'][data-played='true'] {
    display: none;
}
.node[data-type='tag_pass'] > code { /* (valid) */
    /* The target character color `--character-color` is set inline. */
    /* It also comes with `[data-character-id]` and `[data-character-name]` as well */
    display: inline-block;
    padding: 0.5rem 1rem;
    margin-bottom: 0.5rem;
    border: dashed 0.125rem var(--character-color);
    border-left-width: 1.5rem;
    border-left-style: solid;
    margin-inline-end: 0.75rem;
    word-break: break-all;
}
.node[data-type='tag_pass'] > code > div { /* (tag group) */
    margin: 0;
}
.node[data-type='tag_pass'] > code > div > span { /* (checkable) */
    display: inline-block;
    padding: 0.5rem 1rem;
    margin: 0.25rem 0.5rem;
    border: solid 0.125rem var(--character-color);
    border-radius: 1rem;
    word-break: break-all;
}
.node[data-type='tag_pass'] > span { /* (invalid) */
    display: inline-block;
    margin-bottom: 0.5rem;
    margin-inline-end: 0.75rem;
}
.node[data-type='tag_pass'] button { /* both skip and apply */
    margin: 0.25rem;
}

/* user_input */
.node[data-type='user_input'] {}
.node[data-type='user_input'] input {
    margin-right: 1rem;
}
.node[data-type='user_input'][data-valid='false'] input {
    border-color: var(--color-e);
}
.node[data-type='user_input'] p {}
.node[data-type='user_input'] label {
    margin-right: 1rem;
    cursor: pointer;
    font-weight: var(--font-weight-buttons);
}
.node[data-type='user_input']:not([data-played='true']) label:hover {
    color: var(--color-5);
}
.node[data-type='user_input'][data-played='true'] input,
.node[data-type='user_input'][data-played='true'] label {
    pointer-events: none;
}
.node[data-type='user_input'] button { /* both buttons */
    margin: 0.25rem;
}
.node[data-type='user_input'][data-played='true'] button {
    display: none;
}
.node[data-type='user_input'][data-valid='false'] button:nth-of-type(1) { /* apply/continue */
    filter: grayscale(1) opacity(0.5);
}
.node[data-type='user_input'][data-valid='false'] button:nth-of-type(2) { /* skip */ }

/* variable_update */
.node[data-type='variable_update'] {}
.node[data-type='variable_update'][data-played='true'] {
    display: none;
}
.node[data-type='variable_update'] /*code*/.expression {
    word-break: break-all;
}
.node[data-type='variable_update'] button {
    margin: 0.5rem;
}

</style>
        <!-- @inline-end -->
    </head>
    <body>
        <header>
            <h1>{{project_title}}</h1>
        </header>
        <main>
            <section id="console">
                <article id="content">
                    <!-- Here will be nodes! -->
                </article>
            </section>
        </main>
        <footer>
            <button id='switch-dark-mode'>Switch Dark Mode</button>
            <button id="play-back">Back</button>
            <p> <time>{{project_last_save}}</time> </p>
            <p> Made with <a href="{{arrow_website}}" target="_blank">Arrow v{{arrow_version}}</a> </p>
        </footer>
    </body>
</html>
